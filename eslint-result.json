[{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/__mocks__/lightweight-charts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/__mocks__/styleMock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/AccountPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/AccountPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/AssetSelector.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/AssetSelector.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setPreferredQuotes'. Either include it or remove the dependency array.","line":54,"column":6,"nodeType":"ArrayExpression","endLine":54,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [selectedMarket, setPreferredQuotes]","fix":{"range":[1869,1885],"text":"[selectedMarket, setPreferredQuotes]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has missing dependencies: 'priceChanges' and 'selectedMarket'. Either include them or remove the dependency array.","line":170,"column":5,"nodeType":"ArrayExpression","endLine":170,"endColumn":35,"suggestions":[{"desc":"Update the dependencies array to be: [selectedMarket, priceChanges, selectedAsset, onAssetSelect]","fix":{"range":[5936,5966],"text":"[selectedMarket, priceChanges, selectedAsset, onAssetSelect]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6737,6740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6737,6740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6761,6764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6761,6764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9233,9236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9233,9236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, memo, useEffect } from 'react';\nimport {\n  Table,\n  TextInput,\n  Paper,\n  Group,\n  Text,\n  Loader,\n  Badge,\n  ActionIcon,\n  Box,\n  Select,\n  Button,\n  Stack\n} from '@mantine/core';\nimport { createColumnHelper, flexRender, getCoreRowModel, useReactTable, getSortedRowModel, getFilteredRowModel, getPaginationRowModel, type SortingState, type ColumnFiltersState } from '@tanstack/react-table';\nimport { IconSearch, IconRefresh, IconSortAscending, IconSortDescending } from '@tabler/icons-react';\nimport { PriceCell } from './shared';\nimport type { Asset, AssetSelectorProps } from '../types/asset';\nimport { useDebounced } from '../hooks/useDebounced';\nimport { usePriceChangeAnimation } from '../hooks/usePriceChangeAnimation';\nimport { useAssets } from '../hooks/useAssets';\n\nconst columnHelper = createColumnHelper<Asset>();\n\nconst AssetSelector: React.FC<AssetSelectorProps> = ({\n  selectedAsset,\n  onAssetSelect,\n  assets,\n  loading = false,\n  error = null,\n}) => {\n  // Stan dla sortowania, filtrowania, paginacji\n  const [sorting, setSorting] = useState<SortingState>([]);\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [globalFilter, setGlobalFilter] = useState('');\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 10,\n  });\n  // Filtr rynku (quote): ALL, USDT, BTC, ETH, BNB\n  const [selectedMarket, setSelectedMarket] = useState<'ALL' | 'USDT' | 'BTC' | 'ETH' | 'BNB'>('USDT');\n\n  // Skieruj subskrypcje WS na wybrany rynek (optymalizacja ruchu)\n  const { setPreferredQuotes } = useAssets();\n  useEffect(() => {\n    if (selectedMarket === 'ALL') {\n      setPreferredQuotes(null);\n    } else {\n      setPreferredQuotes([selectedMarket]);\n    }\n    // po zmianie rynku wróć na pierwszą stronę\n    setPagination((prev) => ({ ...prev, pageIndex: 0 }));\n  }, [selectedMarket]);\n\n  // Debounced search dla lepszej wydajności\n  const debouncedGlobalFilter = useDebounced(globalFilter, 300);\n  \n  // Hook do animacji zmian cen\n  // Filtrowanie/grupowanie wg wybranego rynku\n  const displayAssets = useMemo(() => {\n    if (selectedMarket !== 'ALL') {\n      return assets.filter(a => a.quoteAsset === selectedMarket);\n    }\n    // ALL: wybierz dla każdej monety jedną parę wg preferencji quote\n    const preference = ['USDT', 'BTC', 'ETH', 'BNB'];\n    const byBase = new Map<string, Asset>();\n    for (const asset of assets) {\n      const current = byBase.get(asset.baseAsset);\n      if (!current) {\n        byBase.set(asset.baseAsset, asset);\n        continue;\n      }\n      const curRank = preference.indexOf(current.quoteAsset);\n      const nextRank = preference.indexOf(asset.quoteAsset);\n      const curScore = curRank === -1 ? Number.MAX_SAFE_INTEGER : curRank;\n      const nextScore = nextRank === -1 ? Number.MAX_SAFE_INTEGER : nextRank;\n      if (nextScore < curScore) byBase.set(asset.baseAsset, asset);\n      // jeśli ten sam priorytet, wybierz większy wolumen\n      else if (nextScore === curScore && asset.volume > current.volume) byBase.set(asset.baseAsset, asset);\n    }\n    return Array.from(byBase.values());\n  }, [assets, selectedMarket]);\n\n  // Hook do animacji zmian cen bazujący na faktycznie renderowanych wierszach\n  const priceChanges = usePriceChangeAnimation(displayAssets);\n\n  // Definicja kolumn dla tabeli\n  const columns = useMemo(\n    () => [\n      columnHelper.accessor('baseAsset', {\n        header: 'Krypto',\n        cell: (info) => {\n          const base = info.getValue();\n          const quote = info.row.original.quoteAsset;\n          return (\n            <Group gap={6} wrap=\"nowrap\">\n              <Text fw={600} c=\"blue\">{base}</Text>\n              {selectedMarket === 'ALL' && (\n                <Badge variant=\"light\" size=\"xs\" color=\"gray\">{quote}</Badge>\n              )}\n            </Group>\n          );\n        },\n      }),\n      columnHelper.accessor('price', {\n        header: 'Cena',\n        cell: (info) => {\n          const symbol = info.row.original.symbol;\n          const change = priceChanges.get(symbol);\n          const price = info.getValue();\n          \n          return (\n            <PriceCell \n              price={price}\n              change={change || undefined}\n            />\n          );\n        },\n      }),\n      columnHelper.accessor('priceChangePercent', {\n        header: '24h %',\n        cell: (info) => {\n          const value = info.getValue();\n          const isPositive = value >= 0;\n          return (\n            <Badge\n              color={isPositive ? 'teal' : 'red'}\n              variant=\"light\"\n              size=\"sm\"\n            >\n              {isPositive ? '+' : ''}{value.toFixed(2)}%\n            </Badge>\n          );\n        },\n      }),\n      columnHelper.accessor('volume', {\n        header: 'Wolumen 24h',\n        cell: (info) => {\n          const v = info.getValue();\n          let display: string;\n          if (v === 0) display = '0';\n          else if (v >= 1_000_000_000) display = (v / 1_000_000_000).toFixed(2) + 'B';\n          else if (v >= 1_000_000) display = (v / 1_000_000).toFixed(2) + 'M';\n          else if (v >= 10_000) display = (v / 1_000).toFixed(2) + 'K';\n          else if (v >= 1) display = v.toFixed(2);\n          else if (v >= 0.01) display = v.toFixed(4); // małe ale czytelne\n          else display = v.toExponential(2);\n          return (\n            <Text ta=\"right\" ff=\"monospace\" size=\"sm\">\n              {display}\n            </Text>\n          );\n        },\n      }),\n      columnHelper.display({\n        id: 'actions',\n        header: 'Akcje',\n        cell: (info) => (\n          <Button\n            size=\"xs\"\n            variant={selectedAsset === info.row.original.symbol ? 'filled' : 'outline'}\n            onClick={() => onAssetSelect(info.row.original)}\n          >\n            {selectedAsset === info.row.original.symbol ? 'Wybrano' : 'Wybierz'}\n          </Button>\n        ),\n      }),\n    ],\n    [selectedAsset, onAssetSelect]\n  );\n\n  // Konfiguracja tabeli TanStack\n  const table = useReactTable({\n    data: displayAssets,\n    columns,\n    state: {\n      sorting,\n      columnFilters,\n      globalFilter: debouncedGlobalFilter, // Use debounced value\n      pagination,\n    },\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    // Ważne: nie resetuj paginacji przy każdej zmianie danych (np. update tickera)\n    autoResetPageIndex: false,\n  debugTable: (typeof process !== 'undefined' && (process as any).env && (process as any).env.NODE_ENV === 'development') || false,\n  });\n\n  // Zabezpieczenie: jeśli po filtracji/zmianie pageSize obecny pageIndex wykracza poza zakres, zawęź go\n  useEffect(() => {\n    const pageCount = table.getPageCount();\n    if (pageCount === 0 && pagination.pageIndex !== 0) {\n      setPagination((prev) => ({ ...prev, pageIndex: 0 }));\n      return;\n    }\n    if (pageCount > 0 && pagination.pageIndex > pageCount - 1) {\n      setPagination((prev) => ({ ...prev, pageIndex: pageCount - 1 }));\n    }\n  }, [displayAssets.length, debouncedGlobalFilter, pagination.pageSize, sorting, table, pagination.pageIndex]);\n\n  if (loading) {\n    return (\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"center\">\n          <Loader size=\"md\" />\n          <Text>Ładowanie aktywów...</Text>\n        </Group>\n      </Paper>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"center\" c=\"red\">\n          <Text>Błąd: {error}</Text>\n          <ActionIcon variant=\"outline\" color=\"red\">\n            <IconRefresh size={16} />\n          </ActionIcon>\n        </Group>\n      </Paper>\n    );\n  }\n\n  return (\n    <Stack gap=\"md\">\n      {/* Sekcja wyszukiwania i filtrów */}\n      <Paper p=\"md\" withBorder>\n        <Stack gap=\"sm\">\n          <Group justify=\"space-between\">\n            <Text size=\"lg\" fw={600}>\n              Wybór aktywa\n            </Text>\n            <Group gap=\"xs\">\n              <Text size=\"sm\" c=\"dimmed\">\n                Widoczne: {table.getFilteredRowModel().rows.length} / {assets.length} aktywów {selectedMarket !== 'ALL' ? `(rynek ${selectedMarket})` : ``}\n              </Text>\n            </Group>\n          </Group>\n\n          <Group>\n            <TextInput\n              placeholder=\"Szukaj par (np. BTC, ETH...)\"\n              leftSection={<IconSearch size={16} />}\n              value={globalFilter ?? ''}\n              onChange={(event) => setGlobalFilter(event.currentTarget.value)}\n              style={{ flexGrow: 1 }}\n            />\n            <Select\n              placeholder=\"Rynek\"\n              data={[\n                { value: 'ALL', label: 'Wszystkie rynki' },\n                { value: 'USDT', label: 'Rynek USDT' },\n                { value: 'BNB', label: 'Rynki BNB' },\n                { value: 'BTC', label: 'Rynki BTC' },\n                { value: 'ETH', label: 'Rynki ETH' },\n              ]}\n              value={selectedMarket}\n              onChange={(value) => setSelectedMarket((value as any) ?? 'ALL')}\n              w={160}\n            />\n            <Select\n              placeholder=\"Rozmiar strony\"\n              data={[\n                { value: '5', label: '5' },\n                { value: '10', label: '10' },\n                { value: '25', label: '25' },\n                { value: '50', label: '50' },\n              ]}\n              value={pagination.pageSize.toString()}\n              onChange={(value) =>\n                setPagination((prev) => ({\n                  ...prev,\n                  pageSize: parseInt(value || '10'),\n                  pageIndex: 0,\n                }))\n              }\n              w={120}\n            />\n          </Group>\n        </Stack>\n      </Paper>\n\n      {/* Tabela */}\n      <Paper withBorder>\n        <Table striped highlightOnHover>\n          <Table.Thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <Table.Tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => (\n                  <Table.Th key={header.id}>\n                    {header.isPlaceholder ? null : (\n                      <Group gap=\"xs\">\n                        <Box\n                          style={{ cursor: header.column.getCanSort() ? 'pointer' : 'default' }}\n                          onClick={header.column.getToggleSortingHandler()}\n                        >\n                          {flexRender(\n                            header.column.columnDef.header,\n                            header.getContext()\n                          )}\n                        </Box>\n                        {header.column.getCanSort() && (\n                          <ActionIcon\n                            size=\"xs\"\n                            variant=\"transparent\"\n                            color=\"dimmed\"\n                          >\n                            {header.column.getIsSorted() === 'asc' ? (\n                              <IconSortAscending size={12} />\n                            ) : header.column.getIsSorted() === 'desc' ? (\n                              <IconSortDescending size={12} />\n                            ) : null}\n                          </ActionIcon>\n                        )}\n                      </Group>\n                    )}\n                  </Table.Th>\n                ))}\n              </Table.Tr>\n            ))}\n          </Table.Thead>\n          <Table.Tbody>\n            {table.getRowModel().rows.map((row) => (\n              <Table.Tr\n                key={row.id}\n                style={{\n                  backgroundColor:\n                    selectedAsset === row.original.symbol\n                      ? 'var(--mantine-color-blue-light)'\n                      : undefined,\n                }}\n              >\n                {row.getVisibleCells().map((cell) => (\n                  <Table.Td key={cell.id}>\n                    {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                  </Table.Td>\n                ))}\n              </Table.Tr>\n            ))}\n          </Table.Tbody>\n        </Table>\n\n        {/* Paginacja */}\n        <Group justify=\"space-between\" p=\"md\">\n          <Text size=\"sm\" c=\"dimmed\">\n            Strona {table.getState().pagination.pageIndex + 1} z{' '}\n            {table.getPageCount()} (\n            {table.getFilteredRowModel().rows.length} aktywów)\n          </Text>\n          <Group gap=\"xs\">\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              disabled={!table.getCanPreviousPage()}\n              onClick={() => table.previousPage()}\n            >\n              Poprzednia\n            </Button>\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              disabled={!table.getCanNextPage()}\n              onClick={() => table.nextPage()}\n            >\n              Następna\n            </Button>\n          </Group>\n        </Group>\n      </Paper>\n    </Stack>\n  );\n};\n\nexport default memo(AssetSelector);\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/BotConfigPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3666,3669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3666,3669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport {\n  Paper,\n  Stack,\n  Group,\n  Text,\n  Title,\n  Button,\n  Select,\n  NumberInput,\n  TextInput,\n  Grid,\n  Badge,\n  Alert,\n  Card,\n  Accordion,\n} from '@mantine/core';\nimport {\n  IconSettings,\n  IconRefresh,\n  IconCheck,\n  IconX,\n  IconInfoCircle,\n} from '@tabler/icons-react';\nimport { secureApiCall, API_CONFIG } from '../config/api';\n\ninterface StrategyConfig {\n  type: string;\n  symbol: string;\n  timeframe: string;\n  parameters: {\n    // Common parameters\n    period?: number;\n    \n    // RSI strategy parameters\n    rsi_period?: number;\n    rsi_overbought?: number;  // Changed from rsi_upper\n    rsi_oversold?: number;    // Changed from rsi_lower\n    \n    // Simple MA strategy parameters\n    ma_period?: number;       // Changed from sma_period\n    ma_type?: string;\n    threshold?: number;\n    \n    // Grid trading parameters\n    grid_levels?: number;\n    grid_spacing?: number;\n    grid_amount?: number;\n    \n    // DCA strategy parameters\n    dca_interval?: number;\n    dca_amount?: number;\n    dca_price_drop?: number;\n  };\n  risk_management: {\n    max_position_size: number;\n    stop_loss_percentage: number;\n    take_profit_percentage: number;\n  };\n}\n\ninterface BotConfigPanelProps {\n  isRunning: boolean;\n  onConfigUpdate?: () => void;\n}\n\nconst BotConfigPanel: React.FC<BotConfigPanelProps> = ({ isRunning, onConfigUpdate }) => {\n  const [config, setConfig] = useState<StrategyConfig | null>(null);\n  const [strategies, setStrategies] = useState<Array<{value: string, label: string}>>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState(false);\n\n  const loadBotConfig = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await secureApiCall(API_CONFIG.ENDPOINTS.BOT_CONFIG);\n      const data = await response.json();\n      console.log('Bot config response:', data);\n      if (data && data.config) {\n        setConfig(data.config);\n      }\n    } catch (error) {\n      console.error('Failed to load bot config:', error);\n      setError('Failed to load configuration');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadStrategies = async () => {\n    try {\n      const response = await secureApiCall(API_CONFIG.ENDPOINTS.BOT_STRATEGIES);\n      const data = await response.json();\n      console.log('Strategies response:', data);\n      if (data && data.strategies) {\n        // Przekształć obiekt strategii na tablicę dla Select komponentu\n        const strategiesObj = data.strategies;\n        const strategiesArray = Object.keys(strategiesObj).map(key => ({\n          value: key,\n          label: strategiesObj[key].name || key\n        }));\n        setStrategies(strategiesArray);\n      }\n    } catch (error) {\n      console.error('Failed to load strategies:', error);\n      setError('Failed to load strategies');\n    }\n  };\n\n  const updateConfig = async () => {\n    if (!config) return;\n    \n    try {\n      setLoading(true);\n      setError(null);\n      setSuccess(false);\n      \n      console.log('Sending config update:', config);\n      const response = await fetch(API_CONFIG.BASE_URL + API_CONFIG.ENDPOINTS.BOT_CONFIG, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(config),\n      });\n      const data = await response.json();\n      console.log('Config update response:', data);\n      \n      setSuccess(true);\n      if (onConfigUpdate) {\n        onConfigUpdate();\n      }\n      \n      setTimeout(() => setSuccess(false), 3000);\n    } catch (error: any) {\n      console.error('Failed to update config:', error);\n      setError(error.response?.data?.detail || 'Failed to update configuration');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadBotConfig();\n    loadStrategies();\n  }, []);\n\n  if (!config) {\n    return (\n      <Paper p=\"md\">\n        <Stack>\n          <Group>\n            <IconSettings size={24} />\n            <Title order={3}>Bot Configuration</Title>\n          </Group>\n          {loading && <Text>Loading...</Text>}\n          {error && <Alert color=\"red\" icon={<IconX size={16} />}>{error}</Alert>}\n        </Stack>\n      </Paper>\n    );\n  }\n\n  return (\n    <Paper p=\"md\">\n      <Stack>\n        <Group justify=\"space-between\">\n          <Group>\n            <IconSettings size={24} />\n            <Title order={3}>Bot Configuration</Title>\n          </Group>\n          <Group>\n            <Button \n              variant=\"light\" \n              leftSection={<IconRefresh size={16} />}\n              onClick={() => { loadBotConfig(); loadStrategies(); }}\n              loading={loading}\n            >\n              Refresh\n            </Button>\n            <Button \n              onClick={updateConfig}\n              loading={loading}\n              disabled={isRunning}\n              leftSection={<IconCheck size={16} />}\n            >\n              Save Configuration\n            </Button>\n          </Group>\n        </Group>\n\n        {error && (\n          <Alert color=\"red\" icon={<IconX size={16} />}>\n            {error}\n          </Alert>\n        )}\n\n        {success && (\n          <Alert color=\"green\" icon={<IconCheck size={16} />}>\n            Configuration updated successfully!\n          </Alert>\n        )}\n\n        {isRunning && (\n          <Alert color=\"orange\" icon={<IconInfoCircle size={16} />}>\n            Bot is running. Stop the bot to modify configuration.\n          </Alert>\n        )}\n\n        <Grid>\n          <Grid.Col span={6}>\n            <Select\n              label=\"Strategy Type\"\n              placeholder=\"Select strategy\"\n              data={strategies}\n              value={config.type}\n              onChange={(value) => setConfig({ ...config, type: value || '' })}\n              disabled={isRunning}\n            />\n          </Grid.Col>\n          <Grid.Col span={6}>\n            <TextInput\n              label=\"Symbol\"\n              placeholder=\"e.g., BTCUSDT\"\n              value={config.symbol}\n              onChange={(event) => setConfig({ ...config, symbol: event.target.value })}\n              disabled={isRunning}\n            />\n          </Grid.Col>\n          <Grid.Col span={6}>\n            <Select\n              label=\"Timeframe\"\n              placeholder=\"Select timeframe\"\n              data={['1m', '5m', '15m', '1h', '4h', '1d']}\n              value={config.timeframe}\n              onChange={(value) => setConfig({ ...config, timeframe: value || '1m' })}\n              disabled={isRunning}\n            />\n          </Grid.Col>\n        </Grid>\n\n        <Accordion defaultValue=\"strategy\">\n          <Accordion.Item value=\"strategy\">\n            <Accordion.Control>Strategy Parameters</Accordion.Control>\n            <Accordion.Panel>\n              <Grid>\n                {config.type === 'simple_ma' && (\n                  <>\n                    <Grid.Col span={6}>\n                      <NumberInput\n                        label=\"MA Period\"\n                        value={config.parameters.ma_period || 20}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, ma_period: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={5}\n                        max={100}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={6}>\n                      <NumberInput\n                        label=\"Threshold (%)\"\n                        value={config.parameters.threshold || 0.5}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, threshold: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={0.1}\n                        max={5}\n                        step={0.1}\n                      />\n                    </Grid.Col>\n                  </>\n                )}\n                \n                {config.type === 'rsi' && (\n                  <>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"RSI Period\"\n                        value={config.parameters.rsi_period || 14}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, rsi_period: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={5}\n                        max={50}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"RSI Oversold\"\n                        value={config.parameters.rsi_oversold || 30}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, rsi_oversold: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={10}\n                        max={40}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"RSI Overbought\"\n                        value={config.parameters.rsi_overbought || 70}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, rsi_overbought: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={60}\n                        max={90}\n                      />\n                    </Grid.Col>\n                  </>\n                )}\n\n                {config.type === 'grid' && (\n                  <>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Grid Levels\"\n                        value={config.parameters.grid_levels || 10}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, grid_levels: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={3}\n                        max={50}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Grid Spacing (%)\"\n                        value={config.parameters.grid_spacing || 1}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, grid_spacing: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={0.1}\n                        max={10}\n                        step={0.1}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Grid Amount ($)\"\n                        value={config.parameters.grid_amount || 100}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, grid_amount: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={10}\n                        max={1000}\n                      />\n                    </Grid.Col>\n                  </>\n                )}\n\n                {config.type === 'dca' && (\n                  <>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"DCA Interval (seconds)\"\n                        value={config.parameters.dca_interval || 3600}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, dca_interval: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={60}\n                        max={86400}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"DCA Amount ($)\"\n                        value={config.parameters.dca_amount || 50}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, dca_amount: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={10}\n                        max={1000}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Price Drop Trigger (%)\"\n                        value={config.parameters.dca_price_drop || 2}\n                        onChange={(value) => setConfig({\n                          ...config,\n                          parameters: { ...config.parameters, dca_price_drop: Number(value) }\n                        })}\n                        disabled={isRunning}\n                        min={0.5}\n                        max={20}\n                        step={0.1}\n                      />\n                    </Grid.Col>\n                  </>\n                )}\n\n                {!config.type && (\n                  <Grid.Col span={12}>\n                    <Text c=\"dimmed\" fs=\"italic\" ta=\"center\" py=\"xl\">\n                      Select a strategy type to configure parameters\n                    </Text>\n                  </Grid.Col>\n                )}\n\n                {config.type && !['simple_ma', 'rsi', 'grid', 'dca'].includes(config.type) && (\n                  <Grid.Col span={12}>\n                    <Text c=\"dimmed\" fs=\"italic\" ta=\"center\" py=\"xl\">\n                      Parameters for \"{config.type}\" strategy are not yet implemented\n                    </Text>\n                  </Grid.Col>\n                )}\n              </Grid>\n            </Accordion.Panel>\n          </Accordion.Item>\n\n          <Accordion.Item value=\"risk\">\n            <Accordion.Control>Risk Management</Accordion.Control>\n            <Accordion.Panel>\n              <Grid>\n                <Grid.Col span={4}>\n                  <NumberInput\n                    label=\"Max Position Size ($)\"\n                    value={config.risk_management.max_position_size}\n                    onChange={(value) => setConfig({\n                      ...config,\n                      risk_management: { \n                        ...config.risk_management, \n                        max_position_size: Number(value) \n                      }\n                    })}\n                    disabled={isRunning}\n                    min={1}\n                    max={10000}\n                  />\n                </Grid.Col>\n                <Grid.Col span={4}>\n                  <NumberInput\n                    label=\"Stop Loss (%)\"\n                    value={config.risk_management.stop_loss_percentage}\n                    onChange={(value) => setConfig({\n                      ...config,\n                      risk_management: { \n                        ...config.risk_management, \n                        stop_loss_percentage: Number(value) \n                      }\n                    })}\n                    disabled={isRunning}\n                    min={0.1}\n                    max={10}\n                    step={0.1}\n                  />\n                </Grid.Col>\n                <Grid.Col span={4}>\n                  <NumberInput\n                    label=\"Take Profit (%)\"\n                    value={config.risk_management.take_profit_percentage}\n                    onChange={(value) => setConfig({\n                      ...config,\n                      risk_management: { \n                        ...config.risk_management, \n                        take_profit_percentage: Number(value) \n                      }\n                    })}\n                    disabled={isRunning}\n                    min={0.1}\n                    max={20}\n                    step={0.1}\n                  />\n                </Grid.Col>\n              </Grid>\n            </Accordion.Panel>\n          </Accordion.Item>\n        </Accordion>\n\n        <Card withBorder>\n          <Stack gap=\"xs\">\n            <Text size=\"sm\" fw={500}>Current Configuration Summary</Text>\n            <Group>\n              <Badge color=\"blue\">{config.type}</Badge>\n              <Badge color=\"green\">{config.symbol}</Badge>\n              <Badge color=\"orange\">{config.timeframe}</Badge>\n            </Group>\n            <Text size=\"xs\" c=\"dimmed\">\n              Risk: ${config.risk_management.max_position_size} max, \n              {config.risk_management.stop_loss_percentage}% SL, \n              {config.risk_management.take_profit_percentage}% TP\n            </Text>\n          </Stack>\n        </Card>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport default BotConfigPanel;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/BotPanel.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[594,597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[594,597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2703,2706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2703,2706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3010,3013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3010,3013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { screen, fireEvent, waitFor } from '@testing-library/react';\nimport { renderWithMantine } from '../testUtils/renderWithMantine';\nimport axios from 'axios';\njest.mock('axios');\nimport BotPanel from './BotPanel';\n// Stub BotConfigPanel to avoid rendering complexity & icon issues in test\njest.mock('./BotConfigPanel', () => () => <div data-testid=\"bot-config-panel\" />);\n\n// Mock WebSocket\nconst mockWebSocket = {\n  send: jest.fn(),\n  isConnected: jest.fn().mockReturnValue(true),\n  destroy: jest.fn(),\n  reconnect: jest.fn(),\n  addStateListener: jest.fn((cb?: any) => cb && cb('CONNECTED')),\n  addListener: jest.fn(),\n};\n\njest.mock('../services/wsClient', () => ({\n  __esModule: true,\n  default: jest.fn().mockImplementation(() => mockWebSocket),\n  ConnectionState: {\n    CONNECTED: 'CONNECTED',\n    DISCONNECTED: 'DISCONNECTED',\n    ERROR: 'ERROR'\n  },\n  getConnectionStateDisplay: jest.fn().mockReturnValue({\n    icon: '🟢',\n    text: 'Połączony',\n    color: '#4CAF50'\n  })\n}));\n\n// Mock useAssets aby uniknąć realnych wywołań axios z fetchAllTradingPairs\njest.mock('../hooks/useAssets', () => ({\n  useAssets: () => ({\n    assets: [{ symbol: 'BTCUSDT', baseAsset: 'BTC', quoteAsset: 'USDT', price: 50000, priceChange: 100, priceChangePercent: 2, volume: 1000000, count: 1, status: 'TRADING' }],\n    loading: false,\n    error: null,\n    refetch: jest.fn(),\n  isConnected: true,\n  setPreferredQuotes: jest.fn()\n  })\n}));\n\n// Mock dla ikon z Tabler\njest.mock('@tabler/icons-react', () => ({\n  IconPlayerPlay: () => <div data-testid=\"play-icon\" />,\n  IconPlayerStop: () => <div data-testid=\"stop-icon\" />,\n  IconTrash: () => <div data-testid=\"trash-icon\" />,\n  IconRefresh: () => <div data-testid=\"refresh-icon\" />,\n  IconAlertCircle: () => <div data-testid=\"alert-icon\" />,\n  IconRobot: () => <div data-testid=\"robot-icon\" />,\n  IconTrendingUp: () => <div data-testid=\"trending-up-icon\" />,\n  IconCurrencyDollar: () => <div data-testid=\"currency-icon\" />,\n  IconClock: () => <div data-testid=\"clock-icon\" />,\n  IconSettings: () => <div data-testid=\"settings-icon\" />,\n  IconChartLine: () => <div data-testid=\"chart-icon\" />,\n}));\n\n// Mock scrollIntoView\nElement.prototype.scrollIntoView = jest.fn();\n\n  const customRender = (component: React.ReactElement) => {\n    (axios.get as jest.Mock).mockResolvedValue({ data: {} });\n    (axios.post as jest.Mock).mockResolvedValue({ data: {} });\n    return renderWithMantine(component);\n  };\n\ndescribe('BotPanel', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Zapewnij że po każdym czyszczeniu ponownie ustawiamy natychmiastową zmianę stanu na CONNECTED\n    mockWebSocket.addStateListener.mockImplementation((cb?: any) => cb && cb('CONNECTED'));\n    mockWebSocket.isConnected.mockReturnValue(true);\n    // Mock fetch dla secureApiCall (ładowanie configu oraz w handleStartBot)\n    global.fetch = jest.fn().mockResolvedValue({\n      json: async () => ({ config: { symbol: 'BTCUSDT', type: 'simple_momentum' } })\n    }) as any;\n  });\n\n  it('renderuje podstawowe elementy', async () => {\n  customRender(<BotPanel />);\n    await waitFor(() => {\n      expect(screen.getByText('Panel Bota Tradingowego')).toBeInTheDocument();\n      expect(screen.getByText('Status Bota')).toBeInTheDocument();\n      expect(screen.getByText(/Status Bota/)).toBeInTheDocument();\n    });\n  });\n\n  it('obsługuje start bota z nowym UI', async () => {\n  customRender(<BotPanel />);\n    const listener = mockWebSocket.addListener.mock.calls[0]?.[0];\n    expect(listener).toBeDefined();\n    mockWebSocket.send.mockImplementation((msg) => {\n      if (msg.type === 'start_bot') {\n  // Symulacja asynchronicznej odpowiedzi statusowej bota\n  setTimeout(() => listener && listener({ type: 'bot_status', running: true, status: { running: true, symbol: msg.symbol, strategy: msg.strategy } }), 0);\n      }\n      return true;\n    });\n    const startButton = await screen.findByText('Uruchom Bota');\n    fireEvent.click(startButton);\n    await waitFor(() => expect(mockWebSocket.send).toHaveBeenCalled());\n    await waitFor(() => expect(screen.getByText('URUCHOMIONY')).toBeInTheDocument());\n  });\n\n  it('obsługuje zatrzymanie bota', async () => {\n    customRender(<BotPanel />);\n    const listener = mockWebSocket.addListener.mock.calls[0]?.[0];\n    expect(listener).toBeDefined();\n    mockWebSocket.send.mockImplementation((msg) => {\n      if (msg.type === 'start_bot') {\n        setTimeout(() => listener && listener({ type: 'bot_status', running: true, status: { running: true, symbol: msg.symbol, strategy: msg.strategy } }), 0);\n      }\n      if (msg.type === 'stop_bot') {\n        setTimeout(() => listener && listener({ type: 'bot_status', running: false, status: { running: false, symbol: 'BTCUSDT', strategy: 'simple_momentum' } }), 0);\n      }\n      return true;\n    });\n    const startButton = await screen.findByText('Uruchom Bota');\n    fireEvent.click(startButton);\n    await waitFor(() => expect(screen.getByText('URUCHOMIONY')).toBeInTheDocument());\n    const stopButton = await screen.findByText('Zatrzymaj Bota');\n    fireEvent.click(stopButton);\n    // Może wystąpić dodatkowe wywołanie 'get_status' po połączeniu, więc sprawdzamy typy zamiast liczby\n    await waitFor(() => {\n      const types = mockWebSocket.send.mock.calls.map(c => c[0]?.type);\n      expect(types).toContain('start_bot');\n      expect(types).toContain('stop_bot');\n    });\n    await waitFor(() => expect(screen.getByText('ZATRZYMANY')).toBeInTheDocument());\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/BotPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1472,1475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1472,1475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":114,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3114,3117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3114,3117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":121,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":121,"endColumn":101,"suggestions":[{"messageId":"addBrackets","fix":{"range":[3201,3859],"text":"{ console.log('Received bot_status:', message); // Debug\n          \n          // Sprawdź czy running jest na najwyższym poziomie lub w status\n          const running = message.running !== undefined ? message.running : message.status?.running;\n          const statusData = {\n            running: running,\n            ...message.status\n          };\n          \n          setBotStatus(statusData);\n          \n          // Reset loading states based on bot status\n          if (running !== undefined) {\n            if (running) {\n              setIsStarting(false);\n            } else {\n              setIsStopping(false);\n            }\n          }\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":122,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":125,"endColumn":13,"suggestions":[{"messageId":"addBrackets","fix":{"range":[3201,3859],"text":"{ console.log('Received bot_status:', message); // Debug\n          \n          // Sprawdź czy running jest na najwyższym poziomie lub w status\n          const running = message.running !== undefined ? message.running : message.status?.running;\n          const statusData = {\n            running: running,\n            ...message.status\n          };\n          \n          setBotStatus(statusData);\n          \n          // Reset loading states based on bot status\n          if (running !== undefined) {\n            if (running) {\n              setIsStarting(false);\n            } else {\n              setIsStopping(false);\n            }\n          }\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":141,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":146,"endColumn":13,"suggestions":[{"messageId":"addBrackets","fix":{"range":[3925,4281],"text":"{ const logEntry: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: message.timestamp || new Date().toLocaleTimeString(),\n            level: (message.level as LogEntry['level']) || extractLogLevel(message.message)\n          };\n          setLogs(prev => [...prev, logEntry]);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":152,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":152,"endColumn":65,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4351,4729],"text":"{ const errorMessage = message.error || message.message;\n          setError(errorMessage);\n          const errorLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: `ERROR: ${errorMessage}`,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'ERROR'\n          };\n          setLogs(prev => [...prev, errorLog]);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":154,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":159,"endColumn":13,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4351,4729],"text":"{ const errorMessage = message.error || message.message;\n          setError(errorMessage);\n          const errorLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: `ERROR: ${errorMessage}`,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'ERROR'\n          };\n          setLogs(prev => [...prev, errorLog]);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":165,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":170,"endColumn":13,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4779,5084],"text":"{ setIsStarting(false);\n          const startedLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'INFO'\n          };\n          setLogs(prev => [...prev, startedLog]);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":176,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":181,"endColumn":13,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5134,5439],"text":"{ setIsStopping(false);\n          const stoppedLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'INFO'\n          };\n          setLogs(prev => [...prev, stoppedLog]);\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handleConnectionStateChange' and 'handleMessage'. Either include them or remove the dependency array.","line":205,"column":6,"nodeType":"ArrayExpression","endLine":205,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [handleConnectionStateChange, handleMessage]","fix":{"range":[6065,6067],"text":"[handleConnectionStateChange, handleMessage]"}}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport {\n  Paper,\n  Stack,\n  Group,\n  Text,\n  Title,\n  Badge,\n  Button,\n  Alert,\n  Loader,\n  Grid,\n  Box,\n  Tabs,\n} from '@mantine/core';\nimport {\n  IconPlayerPlay,\n  IconPlayerStop,\n  IconTrash,\n  IconRefresh,\n  IconAlertCircle,\n  IconRobot,\n  IconCurrencyDollar,\n  IconClock,\n  IconSettings,\n  IconChartLine,\n} from '@tabler/icons-react';\nimport EnhancedWSClient, { ConnectionState, getConnectionStateDisplay } from '../services/wsClient';\nimport BotConfigPanel from './BotConfigPanel';\nimport { secureApiCall, API_CONFIG } from '../config/api';\n\ninterface BotStatus {\n  running: boolean;\n  symbol?: string;\n  strategy?: string;\n  balance?: number;\n  position?: unknown;\n  last_action?: string;\n  timestamp?: string;\n}\n\ninterface LogEntry {\n  id: number;\n  message: string;\n  timestamp: string;\n  level?: 'INFO' | 'WARNING' | 'ERROR' | 'DEBUG';\n}\n\nconst BotPanel: React.FC = () => {\n  const [botStatus, setBotStatus] = useState<BotStatus>({ running: false });\n  const [logs, setLogs] = useState<LogEntry[]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [isStarting, setIsStarting] = useState(false);\n  const [isStopping, setIsStopping] = useState(false);\n  const [connectionState, setConnectionState] = useState<ConnectionState>(ConnectionState.DISCONNECTED);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n  const [botConfig, setBotConfig] = useState<any>(null);\n\n  const wsClientRef = useRef<EnhancedWSClient | null>(null);\n  const logIdCounterRef = useRef(1);\n  const logsEndRef = useRef<HTMLDivElement>(null);\n  const logsContainerRef = useRef<HTMLDivElement>(null);\n\n  const formatBalance = (balance: number): string => {\n    return balance.toLocaleString('en-US', {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    });\n  };\n\n  const requestStatus = () => {\n    if (wsClientRef.current?.isConnected()) {\n      wsClientRef.current.send({ type: 'get_status' });\n    }\n  };\n\n  const loadBotConfig = async () => {\n    try {\n      const response = await secureApiCall(API_CONFIG.ENDPOINTS.BOT_CONFIG);\n      const data = await response.json();\n      setBotConfig(data.config || null);\n    } catch (error) {\n      console.error('Failed to load bot config:', error);\n    }\n  };\n\n  // Auto-scroll logs to bottom (only within logs container)\n  useEffect(() => {\n    if (logsContainerRef.current) {\n      logsContainerRef.current.scrollTop = logsContainerRef.current.scrollHeight;\n    }\n  }, [logs]);\n\n  // Connection state change handler\n  const handleConnectionStateChange = (state: ConnectionState, error?: string) => {\n    setConnectionState(state);\n    setConnectionError(error || null);\n    \n    if (state === ConnectionState.CONNECTED) {\n      setError(null);\n      requestStatus();\n      loadBotConfig(); // Załaduj konfigurację po połączeniu\n    }\n  };\n\n  // Retry connection\n  const handleRetryConnection = () => {\n    if (wsClientRef.current) {\n      wsClientRef.current.reconnect();\n    }\n  };\n\n  // Handle incoming WebSocket messages\n  const handleMessage = (message: any) => {\n    try {\n      switch (message.type) {\n        case 'bot_status':\n          console.log('Received bot_status:', message); // Debug\n          \n          // Sprawdź czy running jest na najwyższym poziomie lub w status\n          const running = message.running !== undefined ? message.running : message.status?.running;\n          const statusData = {\n            running: running,\n            ...message.status\n          };\n          \n          setBotStatus(statusData);\n          \n          // Reset loading states based on bot status\n          if (running !== undefined) {\n            if (running) {\n              setIsStarting(false);\n            } else {\n              setIsStopping(false);\n            }\n          }\n          break;\n          \n        case 'bot_log':\n        case 'log':\n          const logEntry: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: message.timestamp || new Date().toLocaleTimeString(),\n            level: (message.level as LogEntry['level']) || extractLogLevel(message.message)\n          };\n          setLogs(prev => [...prev, logEntry]);\n          break;\n          \n        case 'bot_error':\n        case 'error':\n          const errorMessage = message.error || message.message;\n          setError(errorMessage);\n          const errorLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: `ERROR: ${errorMessage}`,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'ERROR'\n          };\n          setLogs(prev => [...prev, errorLog]);\n          break;\n          \n        case 'bot_started':\n          setIsStarting(false);\n          const startedLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'INFO'\n          };\n          setLogs(prev => [...prev, startedLog]);\n          break;\n          \n        case 'bot_stopped':\n          setIsStopping(false);\n          const stoppedLog: LogEntry = {\n            id: logIdCounterRef.current++,\n            message: message.message,\n            timestamp: new Date().toLocaleTimeString(),\n            level: 'INFO'\n          };\n          setLogs(prev => [...prev, stoppedLog]);\n          break;\n          \n        default:\n          console.log('Unknown message type:', message);\n      }\n    } catch (err) {\n      console.error('Error handling WebSocket message:', err);\n      setError('Błąd podczas przetwarzania wiadomości WebSocket');\n    }\n  };\n\n  // Initialize WebSocket connection\n  useEffect(() => {\n    wsClientRef.current = new EnhancedWSClient('ws://localhost:8001/ws/bot');\n    wsClientRef.current.addListener(handleMessage);\n    wsClientRef.current.addStateListener(handleConnectionStateChange);\n\n    return () => {\n      if (wsClientRef.current) {\n        wsClientRef.current.destroy();\n      }\n    };\n  }, []);\n\n  // Extract log level from message\n  const extractLogLevel = (message: string): LogEntry['level'] => {\n    const upperMessage = message.toUpperCase();\n    if (upperMessage.includes('ERROR')) return 'ERROR';\n    if (upperMessage.includes('WARNING') || upperMessage.includes('WARN')) return 'WARNING';\n    if (upperMessage.includes('DEBUG')) return 'DEBUG';\n    return 'INFO';\n  };\n\n  // Get log level color\n  const getLogLevelColor = (level?: LogEntry['level']): string => {\n    switch (level) {\n      case 'ERROR': return '#EF4444';\n      case 'WARNING': return '#F59E0B';\n      case 'DEBUG': return '#6B7280';\n      default: return '#374151';\n    }\n  };\n\n  const handleStartBot = async () => {\n    if (!wsClientRef.current?.isConnected()) {\n      setError('WebSocket nie jest połączony');\n      return;\n    }\n\n    try {\n      setIsStarting(true);\n      setError(null);\n      \n      // Załaduj aktualną konfigurację przed uruchomieniem\n      let currentConfig = botConfig;\n      try {\n        const response = await secureApiCall('/bot/config');\n        const data = await response.json();\n        currentConfig = data.config || null;\n        setBotConfig(currentConfig);\n      } catch (configError) {\n        console.error('Failed to load config, using cached version:', configError);\n      }\n      \n      const startCommand = {\n        type: 'start_bot',\n        symbol: currentConfig?.symbol || 'BTCUSDT',\n        strategy: currentConfig?.type || 'simple_momentum'\n      };\n      \n      console.log('Sending start command with config:', { currentConfig, startCommand });\n      wsClientRef.current.send(startCommand);\n      \n      // Add local log entry\n      const startLog: LogEntry = {\n        id: logIdCounterRef.current++,\n        message: `Wysłano komendę uruchomienia bota z strategią ${startCommand.strategy} dla ${startCommand.symbol}...`,\n        timestamp: new Date().toLocaleTimeString(),\n        level: 'INFO'\n      };\n      setLogs(prev => [...prev, startLog]);\n      \n    } catch (err) {\n      console.error('Failed to start bot:', err);\n      setError(err instanceof Error ? err.message : 'Nie udało się uruchomić bota');\n      setIsStarting(false);\n    }\n  };\n\n  const handleStopBot = async () => {\n    if (!wsClientRef.current?.isConnected()) {\n      setError('WebSocket nie jest połączony');\n      return;\n    }\n\n    try {\n      setIsStopping(true);\n      setError(null);\n      \n      wsClientRef.current.send({\n        type: 'stop_bot'\n      });\n      \n      // Add local log entry\n      const stopLog: LogEntry = {\n        id: logIdCounterRef.current++,\n        message: 'Wysłano komendę zatrzymania bota...',\n        timestamp: new Date().toLocaleTimeString(),\n        level: 'INFO'\n      };\n      setLogs(prev => [...prev, stopLog]);\n      \n    } catch (err) {\n      console.error('Failed to stop bot:', err);\n      setError(err instanceof Error ? err.message : 'Nie udało się zatrzymać bota');\n      setIsStopping(false);\n    }\n  };\n\n  const connectionDisplay = getConnectionStateDisplay(connectionState);\n\n  return (\n    <Stack gap=\"md\" p=\"md\">\n      <Tabs defaultValue=\"monitoring\">\n        <Tabs.List>\n          <Tabs.Tab value=\"monitoring\" leftSection={<IconChartLine size={14} />}>\n            Monitoring & Control\n          </Tabs.Tab>\n          <Tabs.Tab value=\"configuration\" leftSection={<IconSettings size={14} />}>\n            Strategy Configuration\n          </Tabs.Tab>\n        </Tabs.List>\n\n        <Tabs.Panel value=\"monitoring\">\n          <Stack gap=\"md\">\n            <Title order={2}>Panel Bota Tradingowego</Title>\n            \n            {/* Connection Status */}\n            <Paper p=\"md\" withBorder>\n              <Group justify=\"space-between\">\n                <Group gap=\"xs\">\n                  <Text size=\"lg\">{connectionDisplay.icon}</Text>\n                  <Text fw={600} c={connectionDisplay.color === '#4CAF50' ? 'teal' : 'red'}>\n                    {connectionDisplay.text}\n                  </Text>\n                  {connectionError && (\n                    <Text size=\"sm\" c=\"red\">\n                      ({connectionError})\n                    </Text>\n                  )}\n                </Group>\n                \n                {(connectionState === ConnectionState.ERROR || connectionState === ConnectionState.DISCONNECTED) && (\n                  <Button\n                    size=\"xs\"\n                    variant=\"outline\"\n                    leftSection={<IconRefresh size={14} />}\n                    onClick={handleRetryConnection}\n                  >\n                    Ponów połączenie\n                  </Button>\n                )}\n              </Group>\n            </Paper>\n            \n            {/* Error Display */}\n            {error && (\n              <Alert \n                icon={<IconAlertCircle size={16} />}\n                title=\"Błąd\"\n                color=\"red\"\n                variant=\"light\"\n                withCloseButton\n                onClose={() => setError(null)}\n              >\n                {error}\n              </Alert>\n            )}\n\n            {/* Bot Status */}\n            <Paper p=\"md\" withBorder>\n              <Group justify=\"space-between\" mb=\"md\">\n                <Group gap=\"xs\" align=\"center\">\n                  <IconRobot size={24} />\n                  <Text size=\"lg\" fw={600}>Status Bota</Text>\n                </Group>\n                \n                <Badge \n                  color={botStatus.running ? 'green' : 'gray'} \n                  size=\"lg\"\n                  variant={botStatus.running ? 'filled' : 'light'}\n                >\n                  {botStatus.running ? 'URUCHOMIONY' : 'ZATRZYMANY'}\n                </Badge>\n              </Group>\n              \n              <Grid>\n                {botStatus.symbol && (\n                  <Grid.Col span={6}>\n                    <Stack gap={2}>\n                      <Text size=\"sm\" c=\"dimmed\" fw={500}>Para</Text>\n                      <Text fw={600}>{botStatus.symbol}</Text>\n                    </Stack>\n                  </Grid.Col>\n                )}\n                \n                {botStatus.strategy && (\n                  <Grid.Col span={6}>\n                    <Stack gap={2}>\n                      <Text size=\"sm\" c=\"dimmed\" fw={500}>Strategia</Text>\n                      <Text fw={600}>{botStatus.strategy}</Text>\n                    </Stack>\n                  </Grid.Col>\n                )}\n                \n                {botStatus.balance !== undefined && (\n                  <Grid.Col span={6}>\n                    <Stack gap={2}>\n                      <Text size=\"sm\" c=\"dimmed\" fw={500}>Saldo</Text>\n                      <Group gap=\"xs\">\n                        <IconCurrencyDollar size={16} color=\"var(--mantine-color-teal-6)\" />\n                        <Text fw={700} ff=\"monospace\" size=\"lg\">\n                          {formatBalance(botStatus.balance)}\n                        </Text>\n                      </Group>\n                    </Stack>\n                  </Grid.Col>\n                )}\n                \n                {botStatus.last_action && (\n                  <Grid.Col span={6}>\n                    <Stack gap={2}>\n                      <Text size=\"sm\" c=\"dimmed\" fw={500}>Ostatnia akcja</Text>\n                      <Group gap=\"xs\">\n                        <IconClock size={16} color=\"var(--mantine-color-blue-6)\" />\n                        <Text fw={600}>{botStatus.last_action}</Text>\n                      </Group>\n                    </Stack>\n                  </Grid.Col>\n                )}\n              </Grid>\n            </Paper>\n\n            {/* Bot Controls */}\n            <Paper p=\"md\" withBorder>\n              <Group gap=\"md\" justify=\"space-between\">\n                <Group gap=\"sm\">\n                  <Button\n                    leftSection={<IconPlayerPlay size={16} />}\n                    onClick={handleStartBot}\n                    loading={isStarting}\n                    disabled={botStatus.running || connectionState !== ConnectionState.CONNECTED}\n                    color=\"green\"\n                  >\n                    Uruchom Bota\n                  </Button>\n\n                  <Button\n                    leftSection={<IconPlayerStop size={16} />}\n                    onClick={handleStopBot}\n                    loading={isStopping}\n                    disabled={!botStatus.running || connectionState !== ConnectionState.CONNECTED}\n                    color=\"red\"\n                    variant=\"outline\"\n                  >\n                    Zatrzymaj Bota\n                  </Button>\n                </Group>\n\n                <Group gap=\"sm\">\n                  <Button\n                    leftSection={<IconTrash size={16} />}\n                    onClick={() => setLogs([])}\n                    disabled={logs.length === 0}\n                    variant=\"light\"\n                    color=\"red\"\n                  >\n                    Wyczyść Logi\n                  </Button>\n\n                  <Button\n                    leftSection={<IconRefresh size={16} />}\n                    onClick={() => requestStatus()}\n                    variant=\"light\"\n                    disabled={connectionState !== ConnectionState.CONNECTED}\n                  >\n                    Odśwież\n                  </Button>\n                </Group>\n              </Group>\n            </Paper>\n\n            {/* Logs Panel */}\n            <Paper p=\"md\" withBorder>\n              <Stack gap=\"sm\">\n                <Group justify=\"space-between\">\n                  <Text size=\"lg\" fw={600}>Logi Bota</Text>\n                  {connectionState !== ConnectionState.CONNECTED && (\n                    <Loader size=\"sm\" />\n                  )}\n                </Group>\n                \n                <Box\n                  ref={logsContainerRef}\n                  style={{ \n                    height: '400px', \n                    overflow: 'auto', \n                    backgroundColor: '#1a1b1e', \n                    color: '#ffffff', \n                    padding: '12px',\n                    borderRadius: '8px',\n                    fontFamily: 'var(--mantine-font-family-monospace)',\n                    fontSize: '13px',\n                    border: '1px solid var(--mantine-color-gray-3)',\n                  }}\n                >\n                  {logs.length === 0 ? (\n                    <Text c=\"dimmed\" fs=\"italic\">\n                      Brak logów. Uruchom bota aby zobaczyć aktywność.\n                    </Text>\n                  ) : (\n                    logs.map((log) => (\n                      <Group key={log.id} gap=\"sm\" align=\"flex-start\" wrap=\"nowrap\" mb=\"xs\">\n                        <Text c=\"dimmed\" size=\"xs\" style={{ minWidth: '80px', fontFamily: 'monospace' }}>\n                          [{log.timestamp}]\n                        </Text>\n                        <Text \n                          size=\"xs\"\n                          fw={700}\n                          c={getLogLevelColor(log.level)}\n                          style={{ minWidth: '70px' }}\n                        >\n                          {log.level}:\n                        </Text>\n                        <Text size=\"xs\" style={{ wordBreak: 'break-word', flex: 1 }}>\n                          {log.message}\n                        </Text>\n                      </Group>\n                    ))\n                  )}\n                  <div ref={logsEndRef} />\n                </Box>\n              </Stack>\n            </Paper>\n          </Stack>\n        </Tabs.Panel>\n\n        <Tabs.Panel value=\"configuration\">\n          <BotConfigPanel \n            isRunning={botStatus.running}\n            onConfigUpdate={() => {\n              // Refresh bot status and config after config update\n              setTimeout(() => {\n                requestStatus();\n                loadBotConfig();\n              }, 500);\n            }}\n          />\n        </Tabs.Panel>\n      </Tabs>\n    </Stack>\n  );\n};\n\nexport default BotPanel;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/DiagnosticsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/FreshnessBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/IndicatorPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport {\n  Paper,\n  Stack,\n  Group,\n  Text,\n  Button,\n  Select,\n  NumberInput,\n  Badge,\n  ActionIcon,\n  Accordion,\n  Grid,\n  Divider\n} from '@mantine/core';\nimport { IconPlus, IconEye, IconEyeOff, IconTrash, IconChartLine } from '@tabler/icons-react';\nimport { useChartIndicators } from '../hooks/useChartIndicators';\nimport type { IChartApi } from 'lightweight-charts';\n\ninterface IndicatorPanelProps {\n  chartInstance: IChartApi | null;\n  historicalData: any[];\n}\n\nconst IndicatorPanel: React.FC<IndicatorPanelProps> = ({ chartInstance, historicalData }) => {\n  const {\n    indicators,\n    addRSI,\n    addMovingAverage,\n    addMACD,\n    addBollingerBands,\n    removeIndicator,\n    toggleIndicator,\n    clearAllIndicators\n  } = useChartIndicators(chartInstance);\n\n  const [selectedIndicator, setSelectedIndicator] = useState<string>('');\n  \n  // RSI Configuration\n  const [rsiPeriod, setRsiPeriod] = useState(14);\n  const [rsiOverbought, setRsiOverbought] = useState(70);\n  const [rsiOversold, setRsiOversold] = useState(30);\n\n  // Moving Average Configuration\n  const [maPeriod, setMaPeriod] = useState(20);\n  const [maType, setMaType] = useState<'SMA' | 'EMA'>('SMA');\n\n  // MACD Configuration\n  const [macdFast, setMacdFast] = useState(12);\n  const [macdSlow, setMacdSlow] = useState(26);\n  const [macdSignal, setMacdSignal] = useState(9);\n\n  // Bollinger Bands Configuration\n  const [bbPeriod, setBbPeriod] = useState(20);\n  const [bbMultiplier, setBbMultiplier] = useState(2);\n\n  const handleAddIndicator = () => {\n    if (!historicalData || historicalData.length === 0) {\n      console.warn('No historical data available for indicators');\n      return;\n    }\n\n    switch (selectedIndicator) {\n      case 'RSI':\n        addRSI(historicalData, {\n          period: rsiPeriod,\n          overbought: rsiOverbought,\n          oversold: rsiOversold\n        });\n        break;\n      case 'MA':\n        addMovingAverage(historicalData, {\n          period: maPeriod,\n          type: maType\n        });\n        break;\n      case 'MACD':\n        addMACD(historicalData, {\n          fastPeriod: macdFast,\n          slowPeriod: macdSlow,\n          signalPeriod: macdSignal\n        });\n        break;\n      case 'BB':\n        addBollingerBands(historicalData, {\n          period: bbPeriod,\n          multiplier: bbMultiplier\n        });\n        break;\n    }\n    setSelectedIndicator('');\n  };\n\n  const getIndicatorColor = (type: string) => {\n    switch (type) {\n      case 'RSI': return 'orange';\n      case 'MA': return 'blue';\n      case 'MACD': return 'teal';\n      case 'BB': return 'violet';\n      default: return 'gray';\n    }\n  };\n\n  return (\n    <Paper p=\"md\" withBorder>\n      <Stack gap=\"md\">\n        <Group justify=\"space-between\">\n          <Group gap=\"xs\">\n            <IconChartLine size={20} />\n            <Text fw={600} size=\"lg\">Wskaźniki Techniczne</Text>\n          </Group>\n          {indicators.length > 0 && (\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              color=\"red\"\n              leftSection={<IconTrash size={14} />}\n              onClick={clearAllIndicators}\n            >\n              Usuń wszystkie\n            </Button>\n          )}\n        </Group>\n\n        <Divider />\n\n        {/* Add Indicator Section */}\n        <Accordion defaultValue=\"add-indicator\">\n          <Accordion.Item value=\"add-indicator\">\n            <Accordion.Control>Dodaj wskaźnik</Accordion.Control>\n            <Accordion.Panel>\n              <Stack gap=\"md\">\n                <Select\n                  label=\"Wybierz wskaźnik\"\n                  placeholder=\"Wybierz wskaźnik do dodania\"\n                  value={selectedIndicator}\n                  onChange={(value) => setSelectedIndicator(value || '')}\n                  data={[\n                    { value: 'RSI', label: 'RSI (Relative Strength Index)' },\n                    { value: 'MA', label: 'Moving Average' },\n                    { value: 'MACD', label: 'MACD' },\n                    { value: 'BB', label: 'Bollinger Bands' }\n                  ]}\n                />\n\n                {/* RSI Configuration */}\n                {selectedIndicator === 'RSI' && (\n                  <Grid>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Okres\"\n                        value={rsiPeriod}\n                        onChange={(value) => setRsiPeriod(Number(value))}\n                        min={2}\n                        max={50}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Wykupienie\"\n                        value={rsiOverbought}\n                        onChange={(value) => setRsiOverbought(Number(value))}\n                        min={50}\n                        max={90}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Wyprzedanie\"\n                        value={rsiOversold}\n                        onChange={(value) => setRsiOversold(Number(value))}\n                        min={10}\n                        max={50}\n                      />\n                    </Grid.Col>\n                  </Grid>\n                )}\n\n                {/* Moving Average Configuration */}\n                {selectedIndicator === 'MA' && (\n                  <Grid>\n                    <Grid.Col span={6}>\n                      <NumberInput\n                        label=\"Okres\"\n                        value={maPeriod}\n                        onChange={(value) => setMaPeriod(Number(value))}\n                        min={2}\n                        max={200}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={6}>\n                      <Select\n                        label=\"Typ\"\n                        value={maType}\n                        onChange={(value) => setMaType(value as 'SMA' | 'EMA')}\n                        data={[\n                          { value: 'SMA', label: 'Simple MA' },\n                          { value: 'EMA', label: 'Exponential MA' }\n                        ]}\n                      />\n                    </Grid.Col>\n                  </Grid>\n                )}\n\n                {/* MACD Configuration */}\n                {selectedIndicator === 'MACD' && (\n                  <Grid>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Szybka EMA\"\n                        value={macdFast}\n                        onChange={(value) => setMacdFast(Number(value))}\n                        min={2}\n                        max={50}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Wolna EMA\"\n                        value={macdSlow}\n                        onChange={(value) => setMacdSlow(Number(value))}\n                        min={10}\n                        max={100}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={4}>\n                      <NumberInput\n                        label=\"Sygnał\"\n                        value={macdSignal}\n                        onChange={(value) => setMacdSignal(Number(value))}\n                        min={2}\n                        max={20}\n                      />\n                    </Grid.Col>\n                  </Grid>\n                )}\n\n                {/* Bollinger Bands Configuration */}\n                {selectedIndicator === 'BB' && (\n                  <Grid>\n                    <Grid.Col span={6}>\n                      <NumberInput\n                        label=\"Okres\"\n                        value={bbPeriod}\n                        onChange={(value) => setBbPeriod(Number(value))}\n                        min={2}\n                        max={50}\n                      />\n                    </Grid.Col>\n                    <Grid.Col span={6}>\n                      <NumberInput\n                        label=\"Mnożnik\"\n                        value={bbMultiplier}\n                        onChange={(value) => setBbMultiplier(Number(value))}\n                        min={0.5}\n                        max={4}\n                        step={0.1}\n                      />\n                    </Grid.Col>\n                  </Grid>\n                )}\n\n                <Button\n                  leftSection={<IconPlus size={16} />}\n                  onClick={handleAddIndicator}\n                  disabled={!selectedIndicator || !chartInstance || !historicalData.length}\n                  fullWidth\n                >\n                  Dodaj wskaźnik\n                </Button>\n              </Stack>\n            </Accordion.Panel>\n          </Accordion.Item>\n        </Accordion>\n\n        {/* Active Indicators */}\n        {indicators.length > 0 && (\n          <Stack gap=\"xs\">\n            <Text fw={500} size=\"sm\">Aktywne wskaźniki ({indicators.length})</Text>\n            {indicators.map((indicator) => (\n              <Paper key={indicator.id} p=\"xs\" withBorder>\n                <Group justify=\"space-between\">\n                  <Group gap=\"xs\">\n                    <Badge\n                      color={getIndicatorColor(indicator.type)}\n                      variant=\"light\"\n                      size=\"sm\"\n                    >\n                      {indicator.type}\n                    </Badge>\n                    <Text size=\"sm\" fw={500}>\n                      {indicator.name}\n                    </Text>\n                  </Group>\n                  <Group gap=\"xs\">\n                    <ActionIcon\n                      size=\"sm\"\n                      variant=\"subtle\"\n                      color={indicator.visible ? 'blue' : 'gray'}\n                      onClick={() => toggleIndicator(indicator.id)}\n                    >\n                      {indicator.visible ? <IconEye size={14} /> : <IconEyeOff size={14} />}\n                    </ActionIcon>\n                    <ActionIcon\n                      size=\"sm\"\n                      variant=\"subtle\"\n                      color=\"red\"\n                      onClick={() => removeIndicator(indicator.id)}\n                    >\n                      <IconTrash size={14} />\n                    </ActionIcon>\n                  </Group>\n                </Group>\n              </Paper>\n            ))}\n          </Stack>\n        )}\n\n        {/* Info when no indicators */}\n        {indicators.length === 0 && (\n          <Text size=\"sm\" c=\"dimmed\" ta=\"center\" py=\"md\">\n            Brak aktywnych wskaźników. Dodaj wskaźnik powyżej.\n          </Text>\n        )}\n      </Stack>\n    </Paper>\n  );\n};\n\nexport default IndicatorPanel;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/IntervalSelector.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/IntervalSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/MarketPanel.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2148,2151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2148,2151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":83,"column":6,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":83,"endColumn":35}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Mock dla react-chartjs-2 i chart.js, aby uniknąć problemów z canvas w jsdom\njest.mock('react-chartjs-2', () => ({\n  Line: () => <div data-testid=\"mock-line-chart\" />,\n  Bar: () => <div data-testid=\"mock-bar-chart\" />,\n}));\n\njest.mock('chart.js', () => ({\n  Chart: {\n    register: jest.fn(),\n  },\n  LineController: {},\n  LineElement: {},\n  PointElement: {},\n  LinearScale: {},\n  CategoryScale: {},\n  Title: {},\n  Tooltip: {},\n  Legend: {},\n}));\n// Mock lightweight-charts (mapped też przez moduleNameMapper)\njest.mock('lightweight-charts', () => ({\n  createChart: jest.fn(() => ({\n    addSeries: jest.fn(() => ({ setData: jest.fn(), update: jest.fn(), applyOptions: jest.fn() })),\n    addCandlestickSeries: jest.fn(() => ({ setData: jest.fn(), update: jest.fn(), applyOptions: jest.fn() })),\n    timeScale: jest.fn(() => ({ fitContent: jest.fn() })),\n    remove: jest.fn(),\n    applyOptions: jest.fn(),\n  })),\n  CandlestickSeries: jest.fn(),\n}));\n// Mock binanceAPI to uniknąć realnych wywołań i opóźnionych logów po zakończeniu testu\njest.mock('../services/binanceAPI', () => ({\n  fetchLightweightChartsKlines: jest.fn(async (_symbol: string, _interval: string, limit: number) => {\n    // deterministyczne dane świecowe\n    return Array.from({ length: limit }, (_, i) => ({\n      time: 1700000000 + i * 60,\n      open: 100 + i,\n      high: 101 + i,\n      low: 99 + i,\n      close: 100.5 + i,\n    }));\n  })\n}));\nimport '@testing-library/jest-dom';\nimport { render, screen } from '@testing-library/react';\nimport { MantineProvider } from '@mantine/core';\nimport MarketPanel from './MarketPanel';\nimport * as restClient from '../services/restClient';\n\njest.mock('../services/restClient', () => ({\n  getCurrentTicker: jest.fn(async (symbol: string) => ({ symbol, price: '50000', change: '100', changePercent: '2.00%' })),\n  getOrderBook: jest.fn(async (symbol: string) => ({ symbol, bids: [['49900','0.5']], asks: [['50100','0.3']] }))\n}));\njest.mock('../hooks/useAssets');\njest.mock('../services/wsClient', () => ({\n  __esModule: true,\n  default: jest.fn().mockImplementation(() => ({\n    addListener: jest.fn(),\n    addStateListener: jest.fn((cb: any) => cb('CONNECTED')),\n    send: jest.fn(),\n    destroy: jest.fn(),\n    reconnect: jest.fn(),\n    isConnected: jest.fn().mockReturnValue(true)\n  })),\n  ConnectionState: {\n    CONNECTED: 'CONNECTED',\n    DISCONNECTED: 'DISCONNECTED',\n    ERROR: 'ERROR'\n  },\n  getConnectionStateDisplay: jest.fn(() => ({ icon: '🟢', text: 'Połączony', color: '#4CAF50' }))\n}));\n\nconst mockTicker = { symbol: 'BTCUSDT', price: '50000' };\nconst mockOrderbook = {\n  bids: [['49900', '0.5']],\n  asks: [['50100', '0.3']],\n};\n\ndescribe('MarketPanel', () => {\n  beforeEach(() => {\n  (restClient.getCurrentTicker as jest.Mock).mockResolvedValue(mockTicker);\n  (restClient.getOrderBook as jest.Mock).mockResolvedValue(mockOrderbook);\n    (require('../hooks/useAssets').useAssets as jest.Mock).mockReturnValue({\n      assets: [{ symbol: 'BTCUSDT', baseAsset: 'BTC', quoteAsset: 'USDT', price: 50000, priceChange: 100, priceChangePercent: 2, volume: 1000000, count: 1, status: 'TRADING' }],\n      loading: false,\n      error: null,\n      refetch: jest.fn(),\n      isConnected: true,\n      setPreferredQuotes: jest.fn()\n    });\n  });\n\n  it('renderuje ticker i orderbook', async () => {\n    render(<MantineProvider><MarketPanel /></MantineProvider>);\n    expect(await screen.findByText(/BTCUSDT/)).toBeInTheDocument();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/MarketPanel.ticker.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2156,2159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2156,2159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":79,"column":5,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":79,"endColumn":43},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":82,"column":5,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":82,"endColumn":44}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { render, screen, waitFor, act } from '@testing-library/react';\nimport { MantineProvider } from '@mantine/core';\nimport '@testing-library/jest-dom';\nimport MarketPanel from './MarketPanel';\n\n// Mock dependencies\njest.mock('../services/wsClient', () => ({\n  __esModule: true,\n  default: jest.fn().mockImplementation(() => mockEnhancedWSClient),\n  ConnectionState: {\n    CONNECTED: 'CONNECTED',\n    DISCONNECTED: 'DISCONNECTED',\n    ERROR: 'ERROR'\n  },\n  getConnectionStateDisplay: jest.fn(() => ({ icon: '🟢', text: 'Połączony', color: '#4CAF50' }))\n}));\njest.mock('../services/binanceWSClient');\njest.mock('../hooks/useLightweightChart');\njest.mock('../services/restClient', () => ({\n  getCurrentTicker: jest.fn(async (symbol: string) => ({ symbol, price: '45000.00', change: '1000.00', changePercent: '2.27%' })),\n  getOrderBook: jest.fn(async (symbol: string) => ({ symbol, bids: [['45000.00','1.0']], asks: [['45001.00','1.5']] }))\n}));\njest.mock('../hooks/useAssets', () => ({\n  useAssets: () => ({\n    assets: [{ symbol: 'BTCUSDT', baseAsset: 'BTC', quoteAsset: 'USDT', price: 45000, priceChange: 1000, priceChangePercent: 2.27, volume: 1_000_000, count: 1, status: 'TRADING' }],\n    loading: false,\n    error: null,\n    refetch: jest.fn(),\n  isConnected: true,\n  setPreferredQuotes: jest.fn()\n  })\n}));\njest.mock('lightweight-charts', () => ({\n  createChart: jest.fn(() => ({\n    addSeries: jest.fn(() => ({ setData: jest.fn(), update: jest.fn(), applyOptions: jest.fn() })),\n    addCandlestickSeries: jest.fn(() => ({ setData: jest.fn(), update: jest.fn(), applyOptions: jest.fn() })),\n    timeScale: jest.fn(() => ({ fitContent: jest.fn() })),\n    remove: jest.fn(),\n    applyOptions: jest.fn(),\n  })),\n  CandlestickSeries: jest.fn(),\n}));\njest.mock('../services/binanceAPI', () => ({\n  fetchLightweightChartsKlines: jest.fn(async (_symbol: string, _interval: string, limit: number) => Array.from({ length: limit }, (_, i) => ({\n    time: 1700000000 + i * 60,\n    open: 100 + i,\n    high: 101 + i,\n    low: 99 + i,\n    close: 100.5 + i,\n  })))\n}));\n\nconst mockEnhancedWSClient = {\n  addListener: jest.fn(),\n  addStateListener: jest.fn((cb?: any) => cb && cb('CONNECTED')),\n  send: jest.fn(),\n  destroy: jest.fn(),\n  isConnected: jest.fn(() => true)\n};\n\nconst mockBinanceWSClient = {\n  addListener: jest.fn(),\n  destroy: jest.fn(),\n};\n\nconst mockChart = {\n  chartContainerRef: { current: null },\n  setHistoricalData: jest.fn(),\n  updateCandlestick: jest.fn(),\n  fitContent: jest.fn(),\n};\n\ndescribe('MarketPanel - Ticker and OrderBook Integration', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n    jest.clearAllMocks();\n    // EnhancedWSClient mock already provided by jest.mock above\n    // Mock BinanceWSClient\n    require('../services/binanceWSClient').default = jest.fn(() => mockBinanceWSClient);\n    \n    // Mock chart hook\n    require('../hooks/useLightweightChart').default = jest.fn(() => mockChart);\n  });\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers();\n    jest.useRealTimers();\n  });\n\n  const renderWithTimers = () => {\n    process.env.VITE_ENABLE_BINANCE_STREAMS = 'true';\n    render(<MantineProvider><MarketPanel /></MantineProvider>);\n    act(() => {\n      jest.runAllTimers();\n    });\n  };\n\n  test('should handle ticker message from backend WebSocket', async () => {\n  renderWithTimers();\n    \n  // Wait for listener attachment\n  await waitFor(() => expect(mockEnhancedWSClient.addListener).toHaveBeenCalled());\n  const wsListener = mockEnhancedWSClient.addListener.mock.calls[0]?.[0];\n  expect(wsListener).toBeDefined();\n    \n    // Simulate receiving ticker message\n    const tickerMessage = {\n      type: 'ticker',\n      symbol: 'BTCUSDT',\n      price: '45000.00',\n      change: '1000.00',\n      changePercent: '2.27'\n    };\n    \n    act(() => {\n      wsListener(tickerMessage);\n    });\n    \n    // Wait for state updates\n  // PriceDisplay rozbija dane na różne elementy - sprawdzamy symbol i cenę oddzielnie\n  await waitFor(() => expect(screen.getByText('BTC/USDT')).toBeInTheDocument());\n  expect(screen.getByText('$45,000.00')).toBeInTheDocument();\n  expect(screen.getByText('+1,000.00')).toBeInTheDocument();\n  });\n\n  test('should handle orderbook message from backend WebSocket', async () => {\n  renderWithTimers();\n  await waitFor(() => expect(mockEnhancedWSClient.addListener).toHaveBeenCalled());\n  const wsListener = mockEnhancedWSClient.addListener.mock.calls[0]?.[0];\n  expect(wsListener).toBeDefined();\n    \n    // Simulate receiving orderbook message\n    const orderbookMessage = {\n      type: 'orderbook',\n      symbol: 'BTCUSDT',\n      bids: [['45000.00', '1.0'], ['44999.00', '2.0']],\n      asks: [['45001.00', '1.5'], ['45002.00', '0.5']]\n    };\n    \n    act(() => {\n      wsListener(orderbookMessage);\n    });\n    \n    // Wait for state updates\n  await waitFor(() => expect(screen.getByText('Księga Zleceń - BTCUSDT')).toBeInTheDocument());\n  expect(screen.getAllByText('45000.00').length).toBeGreaterThan(0);\n  expect(screen.getAllByText('45001.00').length).toBeGreaterThan(0);\n  });\n\n  test('should filter out ticker messages for unselected symbols', async () => {\n  renderWithTimers();\n  await waitFor(() => expect(mockEnhancedWSClient.addListener).toHaveBeenCalled());\n  const wsListener = mockEnhancedWSClient.addListener.mock.calls[0]?.[0];\n  expect(wsListener).toBeDefined();\n    \n    // Simulate receiving ticker message for different symbol\n    const tickerMessage = {\n      type: 'ticker',\n      symbol: 'ETHUSDT',\n      price: '3000.00',\n      change: '100.00',\n      changePercent: '3.45'\n    };\n    \n    act(() => {\n      wsListener(tickerMessage);\n    });\n    \n    // Should not update UI for unselected symbol\n    await waitFor(() => {\n      expect(screen.queryByText(/ETHUSDT/)).not.toBeInTheDocument();\n    });\n  });\n\n  test('should update chart with Binance kline data', async () => {\n  renderWithTimers();\n  await waitFor(() => expect(mockBinanceWSClient.addListener).toHaveBeenCalled());\n  const binanceListener = mockBinanceWSClient.addListener.mock.calls[0]?.[0];\n  expect(binanceListener).toBeDefined();\n    \n    // Simulate receiving kline data\n    const klineData = {\n      s: 'BTCUSDT',\n      k: {\n        t: 1640995200000, // timestamp\n        o: '44000.00',\n        h: '45000.00',\n        l: '43500.00',\n        c: '44800.00',\n        x: true // kline closed\n      }\n    };\n    \n    act(() => {\n      binanceListener(klineData);\n    });\n    \n    // Verify chart update was called\n    expect(mockChart.updateCandlestick).toHaveBeenCalledWith({\n      time: 1640995200, // converted to seconds\n      open: 44000.00,\n      high: 45000.00,\n      low: 43500.00,\n      close: 44800.00\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/MarketPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2067,2070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2067,2070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4774,4777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4774,4777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5610,5613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5610,5613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7707,7710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7707,7710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":210,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8263,8266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8263,8266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateCandlestick'. Either include it or remove the dependency array.","line":230,"column":6,"nodeType":"ArrayExpression","endLine":230,"endColumn":40,"suggestions":[{"desc":"Update the dependencies array to be: [selectedSymbol, selectedInterval, updateCandlestick]","fix":{"range":[8897,8931],"text":"[selectedSymbol, selectedInterval, updateCandlestick]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setOrderBookThrottled' and 'setTicker'. Either include them or remove the dependency array.","line":310,"column":6,"nodeType":"ArrayExpression","endLine":310,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setOrderBookThrottled, setTicker]","fix":{"range":[11600,11602],"text":"[setOrderBookThrottled, setTicker]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadInitialData'. Either include it or remove the dependency array.","line":330,"column":6,"nodeType":"ArrayExpression","endLine":330,"endColumn":39,"suggestions":[{"desc":"Update the dependencies array to be: [selectedSymbol, connectionState, loadInitialData]","fix":{"range":[12259,12292],"text":"[selectedSymbol, connectionState, loadInitialData]"}}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback, memo } from 'react';\nimport {\n  Paper,\n  Stack,\n  Group,\n  Text,\n  Title,\n  Badge,\n  Alert,\n  Loader,\n  Button,\n  Grid,\n  Box,\n} from '@mantine/core';\nimport { IconAlertCircle, IconRefresh } from '@tabler/icons-react';\nimport EnhancedWSClient, { ConnectionState, getConnectionStateDisplay } from '../services/wsClient';\nimport { getCurrentTicker, getOrderBook } from '../services/restClient';\nimport { fetchLightweightChartsKlines } from '../services/binanceAPI';\nimport BinanceWSClient from '../services/binanceWSClient';\nimport type { BinanceKlineData } from '../services/binanceWSClient';\nimport useLightweightChart from '../hooks/useLightweightChart';\nimport { useThrottledState } from '../hooks/useThrottledState';\nimport { useThrottledCallback } from '../hooks/useThrottledCallback';\nimport type { CandlestickData } from 'lightweight-charts';\nimport AssetSelector from './AssetSelector';\nimport PriceDisplay from './PriceDisplay';\nimport IntervalSelector, { type TimeInterval } from './IntervalSelector';\nimport IndicatorPanel from './IndicatorPanel';\nimport { useAssets } from '../hooks/useAssets';\nimport type { Asset } from '../types/asset';\n\ninterface TickerData {\n  symbol: string;\n  price: string;\n  change: string;\n  changePercent: string;\n}\n\ninterface OrderBookData {\n  symbol: string;\n  bids: [string, string][];\n  asks: [string, string][];\n}\n\nconst MarketPanel: React.FC = () => {\n  const [ticker, setTicker] = useThrottledState<TickerData | null>(null, 150); // Throttle ticker updates\n  const [orderBook, setOrderBook] = useState<OrderBookData | null>(null);\n  const [selectedSymbol, setSelectedSymbol] = useState('BTCUSDT');\n  const [selectedInterval, setSelectedInterval] = useState<TimeInterval>('1m');\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [historyLoaded, setHistoryLoaded] = useState<string | null>(null); // Track which symbol has history loaded\n  const [candlestickData, setCandlestickData] = useState<any[]>([]); // Store historical data for indicators\n  \n  // Hook do zarządzania aktywami z Binance API\n  const { assets, loading: assetsLoading, error: assetsError, refetch: refetchAssets, isConnected } = useAssets();\n  \n  // WebSocket connection state\n  const [connectionState, setConnectionState] = useState<ConnectionState>(ConnectionState.DISCONNECTED);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n  \n  const wsClientRef = useRef<EnhancedWSClient | null>(null);\n  const selectedSymbolRef = useRef<string>(selectedSymbol);\n\n  // Throttled orderbook updates to prevent excessive re-renders\n  const setOrderBookThrottled = useThrottledCallback((newOrderBook: OrderBookData | null) => {\n    setOrderBook(newOrderBook);\n  }, 100); // Limit to ~10 updates per second\n\n  // Keep selectedSymbolRef in sync with selectedSymbol\n  useEffect(() => {\n    selectedSymbolRef.current = selectedSymbol;\n  }, [selectedSymbol]);\n\n  // Debugowanie setup/cleanup WebSocket\n  useEffect(() => {\n    console.log(`[MarketPanel] Setting up WebSocket for ${selectedSymbol}`);\n    return () => {\n      console.log(`[MarketPanel] Cleaning up WebSocket for ${selectedSymbol}`);\n    };\n  }, [selectedSymbol]);\n\n  // Monitoring stanu połączenia\n  useEffect(() => {\n    console.log(`[MarketPanel] Connection state changed: ${connectionState}`);\n    if (connectionError) {\n      console.error(`[MarketPanel] Connection error: ${connectionError}`);\n    }\n  }, [connectionState, connectionError]);\n\n  // Use lightweight charts hook\n  const { chartContainerRef, chartInstance, setHistoricalData, updateCandlestick, fitContent } = useLightweightChart();\n  \n  // Binance WebSocket client for real-time kline data\n  const binanceWSClientRef = useRef<BinanceWSClient | null>(null);\n\n  // Load historical data for chart - using Binance API directly\n  const loadHistoricalData = useCallback(async (symbol: string, interval: TimeInterval = '1m') => {\n    try {\n      setIsLoading(true);\n      console.log(`[MarketPanel] Loading historical data for ${symbol} (${interval}) from Binance API`);\n      \n      const candlestickData = await fetchLightweightChartsKlines(symbol, interval, 100);\n      \n      if (candlestickData && candlestickData.length > 0) {\n        console.log(`[MarketPanel] Got ${candlestickData.length} historical data points`);\n        console.log(`[MarketPanel] Price range: ${Math.min(...candlestickData.map(c => c.low))} - ${Math.max(...candlestickData.map(c => c.high))}`);\n        \n        // Set historical data using lightweight-charts (cast time to any for compatibility)\n        const chartData: CandlestickData[] = candlestickData.map(d => ({\n          ...d,\n          time: d.time as any\n        }));\n        setHistoricalData(chartData);\n        setCandlestickData(candlestickData); // Store for indicators\n        fitContent(); // Fit chart to content\n        setHistoryLoaded(`${symbol}_${interval}`); // Mark history as loaded for this symbol and interval\n      } else {\n        console.warn(`[MarketPanel] No historical data received`);\n      }\n    } catch (err) {\n      console.error('Failed to load historical data:', err);\n      setError('Nie udało się załadować danych historycznych');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [setHistoricalData, fitContent]);\n\n  // Load initial data\n  const loadInitialData = async (symbol: string) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      // Prefer ticker data from assets hook (WebSocket) to reduce REST calls\n      let localTicker: any = null;\n      const asset = assets.find(a => a.symbol === symbol);\n      if (asset) {\n        localTicker = {\n            symbol: asset.symbol,\n            price: asset.price?.toString() || '0',\n            change: asset.priceChange?.toString() || '0',\n            changePercent: `${asset.priceChangePercent?.toFixed(2) || '0'}%`\n        };\n      }\n\n      if (!localTicker) {\n        try {\n          localTicker = await getCurrentTicker(symbol);\n        } catch (e) {\n          console.warn('[MarketPanel] REST ticker fallback failed:', e);\n        }\n      }\n\n      if (localTicker) {\n        setTicker({\n          symbol: localTicker.symbol,\n          price: localTicker.price,\n          change: localTicker.change || '0',\n          changePercent: localTicker.changePercent || '0%'\n        });\n      }\n\n      const orderBookData = await getOrderBook(symbol);\n      if (orderBookData) {\n        setOrderBook({\n          symbol: symbol,\n          bids: Array.isArray(orderBookData.bids) ? orderBookData.bids : [],\n          asks: Array.isArray(orderBookData.asks) ? orderBookData.asks : []\n        });\n      }\n      \n      // Nie ładuj danych historycznych tutaj - zostanie to zrobione w useEffect gdy chart będzie gotowy\n    } catch (err) {\n      console.error('Failed to load initial data:', err);\n      setError('Nie udało się załadować danych początkowych');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Load historical data when component mounts or symbol/interval changes\n  useEffect(() => {\n    const historyKey = `${selectedSymbol}_${selectedInterval}`;\n    if (historyLoaded !== historyKey) {\n      console.log(`[MarketPanel] Loading historical data for ${selectedSymbol} (${selectedInterval})`);\n      loadHistoricalData(selectedSymbol, selectedInterval);\n    }\n  }, [selectedSymbol, selectedInterval, historyLoaded, loadHistoricalData]);\n\n  // Setup Binance WebSocket for real-time kline data\n  useEffect(() => {\n    let mounted = true;\n    \n    // Check if Binance streams are enabled\n    const binanceStreamsEnabled = ((typeof process !== 'undefined' && (process as any).env?.VITE_ENABLE_BINANCE_STREAMS) === 'true');\n    \n    if (!binanceStreamsEnabled) {\n      return;\n    }\n    \n    // Create new Binance WebSocket client for kline data\n    const binanceClient = new BinanceWSClient(selectedSymbol, selectedInterval);\n    binanceWSClientRef.current = binanceClient;\n    \n    binanceClient.addListener((data: BinanceKlineData) => {\n      if (!mounted) return;\n      \n      // Convert to lightweight-charts format and update chart\n      const candlestick: CandlestickData = {\n        time: Math.floor(data.k.t / 1000) as any, // Convert milliseconds to seconds\n        open: parseFloat(data.k.o),\n        high: parseFloat(data.k.h),\n        low: parseFloat(data.k.l),\n        close: parseFloat(data.k.c)\n      };\n      \n      updateCandlestick(candlestick);\n      \n      // Nie aktualizuj tickera tutaj - ticker pochodzi z backend WebSocket\n    });\n    \n    return () => {\n      mounted = false;\n      console.log(`[MarketPanel] Cleaning up Binance WebSocket for ${selectedSymbol} (${selectedInterval})`);\n      if (binanceWSClientRef.current) {\n        binanceWSClientRef.current.destroy();\n        binanceWSClientRef.current = null;\n      }\n    };\n  }, [selectedSymbol, selectedInterval]);\n\n  // Setup WebSocket connection for orderbook and other data (keep existing backend connection)\n  useEffect(() => {\n    let mounted = true;\n    let wsClientLocal: EnhancedWSClient | null = null;\n\n    const setupWebSocket = () => {\n      if (wsClientRef.current) {\n        console.log('[MarketPanel] WebSocket connection already exists, skipping setup');\n        return;\n      }\n\n      if (!mounted) return;\n\n      console.log('[MarketPanel] Setting up persistent WebSocket connection for orderbook/ticker');\n      const wsClient = new EnhancedWSClient('ws://localhost:8001/ws/market', {\n        reconnectInterval: 2000,\n        maxReconnectInterval: 30000,\n        maxReconnectAttempts: 5,\n        heartbeatInterval: 30000,\n        debug: true\n      });\n\n      wsClientRef.current = wsClient;\n      wsClientLocal = wsClient;\n\n      wsClient.addStateListener((state, error) => {\n        if (!mounted) return;\n        console.log(`[MarketPanel] WebSocket state changed: ${state}`);\n        setConnectionState(state);\n        setConnectionError(error || null);\n      });\n\n      wsClient.addListener((msg) => {\n        if (!mounted) return;\n        const currentSelectedSymbol = selectedSymbolRef.current;\n        \n        switch (msg.type) {\n          case 'ticker':\n            // Filter: only process ticker for currently selected symbol\n            if (msg.symbol === currentSelectedSymbol) {\n              setTicker({\n                symbol: msg.symbol as string,\n                price: msg.price as string,\n                change: msg.change as string,\n                changePercent: msg.changePercent as string\n              });\n            }\n            break;\n          case 'orderbook':\n            // Filter: only process orderbook for currently selected symbol\n            if (msg.symbol === currentSelectedSymbol) {\n              setOrderBookThrottled({\n                symbol: msg.symbol as string,\n                bids: Array.isArray(msg.bids) ? (msg.bids as [string, string][]) : [],\n                asks: Array.isArray(msg.asks) ? (msg.asks as [string, string][]) : []\n              });\n            }\n            break;\n        }\n      });\n    };\n\n    // Delay to prevent double connections in Strict Mode\n    const timeoutId = setTimeout(setupWebSocket, 100);\n\n    return () => {\n      mounted = false;\n      clearTimeout(timeoutId);\n      if (wsClientLocal) {\n        console.log('[MarketPanel] Destroying WebSocket connection on component unmount');\n        wsClientLocal.destroy();\n        wsClientLocal = null;\n      }\n      if (wsClientRef.current) {\n        wsClientRef.current.destroy();\n        wsClientRef.current = null;\n      }\n    };\n  }, []); // NO dependencies - persistent connection\n\n  // Handle symbol subscription changes for orderbook\n  useEffect(() => {\n    if (!wsClientRef.current || connectionState !== ConnectionState.CONNECTED) {\n      console.log(`[MarketPanel] WebSocket not ready for subscription. State: ${connectionState}`);\n      return;\n    }\n\n    console.log(`[MarketPanel] Subscribing to ${selectedSymbol} via existing WebSocket connection`);\n    \n    // Send subscription message for new symbol\n    wsClientRef.current.send({ \n      type: 'subscribe', \n      symbol: selectedSymbol \n    });\n\n    // Load initial data for new symbol\n    loadInitialData(selectedSymbol);\n\n  }, [selectedSymbol, connectionState]); // Only depend on symbol and connection state\n\n  const handleSymbolChange = (newSymbol: string) => {\n    setSelectedSymbol(newSymbol);\n    setTicker(null);\n    setOrderBook(null);\n    setError(null);\n    setHistoryLoaded(null); // Reset history loaded flag\n  };\n\n  const handleIntervalChange = (newInterval: TimeInterval) => {\n    setSelectedInterval(newInterval);\n    setHistoryLoaded(null); // Reset history loaded flag to force reload\n  };\n\n  // Nowa funkcja obsługi wyboru aktywa z AssetSelector\n  const handleAssetSelect = (asset: Asset) => {\n    handleSymbolChange(asset.symbol);\n  };\n\n  const handleRetryConnection = () => {\n    if (wsClientRef.current) {\n      wsClientRef.current.reconnect();\n    }\n  };\n\n  const connectionDisplay = getConnectionStateDisplay(connectionState);\n\n  return (\n    <Stack gap=\"md\" p=\"md\">\n      <Title order={2}>Panel Rynkowy</Title>\n      \n      {/* Connection Status */}\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"space-between\">\n          <Group gap=\"xs\">\n            <Text size=\"lg\">{connectionDisplay.icon}</Text>\n            <Text fw={600} c={connectionDisplay.color === '#4CAF50' ? 'teal' : 'red'}>\n              {connectionDisplay.text}\n            </Text>\n            {connectionError && (\n              <Text size=\"sm\" c=\"red\">\n                ({connectionError})\n              </Text>\n            )}\n          </Group>\n          \n          {(connectionState === ConnectionState.ERROR || connectionState === ConnectionState.DISCONNECTED) && (\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              leftSection={<IconRefresh size={14} />}\n              onClick={handleRetryConnection}\n            >\n              Ponów połączenie\n            </Button>\n          )}\n        </Group>\n      </Paper>\n      \n      {/* Asset Selection - Nowy komponent z TanStack Table + Mantine */}\n      <AssetSelector\n        selectedAsset={selectedSymbol}\n        onAssetSelect={handleAssetSelect}\n        assets={assets}\n        loading={assetsLoading}\n        error={assetsError}\n      />\n\n      {/* Dodatkowe informacje o załadowaniu aktywów */}\n      {!assetsLoading && !assetsError && assets.length > 0 && (\n        <Paper p=\"xs\" withBorder>\n          <Group justify=\"center\" gap=\"md\">\n            <Text size=\"xs\" c=\"dimmed\">\n              Załadowano {assets.length} par trading z Binance API\n            </Text>\n            <Badge color={isConnected ? 'teal' : 'red'} variant=\"light\" size=\"xs\">\n              {isConnected ? 'LIVE' : 'OFFLINE'}\n            </Badge>\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              leftSection={<IconRefresh size={12} />}\n              onClick={refetchAssets}\n            >\n              Odśwież\n            </Button>\n          </Group>\n        </Paper>\n      )}\n      \n      {/* Error Display */}\n      {error && (\n        <Alert \n          icon={<IconAlertCircle size={16} />}\n          title=\"Błąd\"\n          color=\"red\"\n          variant=\"light\"\n        >\n          {error}\n        </Alert>\n      )}\n      \n      {/* Loading Indicator */}\n      {isLoading && (\n        <Paper p=\"xl\" withBorder>\n          <Group justify=\"center\" gap=\"md\">\n            <Loader size=\"md\" />\n            <Text>Ładowanie danych...</Text>\n          </Group>\n        </Paper>\n      )}\n      \n      {/* Price Display - Enhanced */}\n      {ticker && (\n        <PriceDisplay ticker={ticker} />\n      )}\n      \n      {/* Chart Controls */}\n      <IntervalSelector \n        selectedInterval={selectedInterval}\n        onIntervalChange={handleIntervalChange}\n        disabled={isLoading}\n      />\n      \n      {/* Price Chart */}\n      <Paper p=\"md\" withBorder>\n        <Stack gap=\"md\">\n          <Group justify=\"space-between\" align=\"center\">\n            <Title order={3}>Wykres Cen</Title>\n            <Badge variant=\"light\" color=\"blue\" size=\"sm\">\n              {selectedInterval.toUpperCase()} • Żywo\n            </Badge>\n          </Group>\n          <Box ref={chartContainerRef} style={{ width: '100%', height: '500px', borderRadius: '8px' }} />\n        </Stack>\n      </Paper>\n      \n      {/* Technical Indicators Panel */}\n      <IndicatorPanel \n        chartInstance={chartInstance} \n        historicalData={candlestickData}\n      />\n      \n      {/* Order Book */}\n      {orderBook && (\n        <Paper p=\"md\" withBorder>\n          <Stack gap=\"md\">\n            <Title order={3}>Księga Zleceń - {orderBook.symbol}</Title>\n            <Grid>\n              <Grid.Col span={6}>\n                <Stack gap=\"xs\">\n                  <Text fw={600} c=\"red\">Asks (Sprzedaż)</Text>\n                  <Stack gap={2}>\n                    {(orderBook.asks || []).slice(0, 10).map((ask, i) => (\n                      <Group key={i} justify=\"space-between\">\n                        <Text size=\"sm\" ff=\"monospace\" c=\"red\" fw={600}>\n                          {parseFloat(ask[0]).toFixed(2)}\n                        </Text>\n                        <Text size=\"sm\" ff=\"monospace\">\n                          {parseFloat(ask[1]).toFixed(6)}\n                        </Text>\n                      </Group>\n                    ))}\n                  </Stack>\n                </Stack>\n              </Grid.Col>\n              <Grid.Col span={6}>\n                <Stack gap=\"xs\">\n                  <Text fw={600} c=\"teal\">Bids (Kupno)</Text>\n                  <Stack gap={2}>\n                    {(orderBook.bids || []).slice(0, 10).map((bid, i) => (\n                      <Group key={i} justify=\"space-between\">\n                        <Text size=\"sm\" ff=\"monospace\" c=\"teal\" fw={600}>\n                          {parseFloat(bid[0]).toFixed(2)}\n                        </Text>\n                        <Text size=\"sm\" ff=\"monospace\">\n                          {parseFloat(bid[1]).toFixed(6)}\n                        </Text>\n                      </Group>\n                    ))}\n                  </Stack>\n                </Stack>\n              </Grid.Col>\n            </Grid>\n          </Stack>\n        </Paper>\n      )}\n    </Stack>\n  );\n};\n\nexport default memo(MarketPanel);","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/OrdersPanel.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[556,559],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[556,559],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { screen, waitFor, fireEvent } from '@testing-library/react';\nimport { renderWithMantine } from '../testUtils/renderWithMantine';\nimport { UserStreamProvider } from '../store/userStream';\nimport OrdersPanel from './OrdersPanel';\n\n// Mock WebSocket\nconst mockWebSocket = {\n  close: jest.fn(),\n  send: jest.fn(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn(),\n  readyState: 0,\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n};\nglobal.WebSocket = jest.fn().mockImplementation(() => mockWebSocket) as any;\n\njest.mock('../hooks/useAssets', () => ({\n  useAssets: () => ({\n    assets: [\n      { symbol: 'BTCUSDT', baseAsset: 'BTC', quoteAsset: 'USDT', price: 50000, priceChange: 0, priceChangePercent: 0, volume: 0, count: 0, status: 'TRADING' },\n      { symbol: 'ETHUSDT', baseAsset: 'ETH', quoteAsset: 'USDT', price: 3000, priceChange: 0, priceChangePercent: 0, volume: 0, count: 0, status: 'TRADING' }\n    ],\n    loading: false,\n    error: null,\n    refetch: jest.fn(),\n    isConnected: true,\n    setPreferredQuotes: jest.fn()\n  })\n}));\n\njest.mock('../services/restClient', () => {\n  const now = Date.now();\n  return {\n    getOpenOrders: jest.fn().mockResolvedValue({ orders: [\n      { symbol: 'BTCUSDT', orderId: 1, orderListId: -1, clientOrderId: 'abc', price: '50000.00', origQty: '0.01000000', executedQty: '0.00000000', cummulativeQuoteQty: '0', status: 'NEW', timeInForce: 'GTC', type: 'LIMIT', side: 'BUY', time: now, updateTime: now, isWorking: true, origQuoteOrderQty: '0' },\n      { symbol: 'ETHUSDT', orderId: 3, orderListId: -1, clientOrderId: 'ghi', price: '3000.00', origQty: '0.20000000', executedQty: '0.00000000', cummulativeQuoteQty: '0', status: 'NEW', timeInForce: 'GTC', type: 'LIMIT', side: 'SELL', time: now, updateTime: now, isWorking: true, origQuoteOrderQty: '0' }\n    ] }),\n    getOrdersHistory: jest.fn().mockImplementation((symbol: string) => {\n      const baseOrderId = symbol === 'BTCUSDT' ? 2 : 4;\n      return Promise.resolve({ orders: [\n        { symbol, orderId: baseOrderId, orderListId: -1, clientOrderId: `hist-${symbol}`, price: '49900.00', origQty: '0.01000000', executedQty: '0.01000000', cummulativeQuoteQty: '0', status: 'FILLED', timeInForce: 'GTC', type: 'LIMIT', side: 'BUY', time: now - 1000, updateTime: now - 1000, isWorking: false, origQuoteOrderQty: '0' }\n      ] });\n    }),\n    cancelOrder: jest.fn().mockResolvedValue({ success: true })\n  };\n});\n\nconst renderWithProviders = (component: React.ReactElement) => {\n  return renderWithMantine(\n    <UserStreamProvider>\n      {component}\n    </UserStreamProvider>\n  );\n};\n\ndescribe('OrdersPanel', () => {\n  it('renderuje i pokazuje otwarte zlecenia wszystkich symboli', async () => {\n    renderWithProviders(<OrdersPanel />);\n    await screen.findByText('Zarządzanie Zleceniami');\n    await screen.findAllByText('Otwarte Zlecenia');\n    await screen.findByText('BTCUSDT');\n    await screen.findByText('ETHUSDT');\n  });\n\n  it('filtruje po symbolu', async () => {\n    renderWithProviders(<OrdersPanel />);\n    const select = await screen.findByTestId('filter-select');\n    fireEvent.change(select, { target: { value: 'BTCUSDT' } });\n    await waitFor(() => expect(screen.getByText('BTCUSDT')).toBeInTheDocument());\n  });\n\n  it('przełącza na historię zleceń', async () => {\n    renderWithProviders(<OrdersPanel />);\n    const historyTab = await screen.findByRole('tab', { name: 'Historia Zleceń' });\n    fireEvent.click(historyTab);\n    await screen.findAllByText('Historia Zleceń');\n    \n    // Sprawdź czy po przełączeniu na historię wyświetla się odpowiedni komunikat\n    expect(screen.getByText(/Wybierz symbol aby załadować historię/)).toBeInTheDocument();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/OrdersPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":10,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":10,"endColumn":27,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[595,624],"text":"type OrdersPanelProps = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[595,624],"text":"type OrdersPanelProps = unknown"},"desc":"Replace empty interface with `unknown`."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'assets'. Either include it or remove the dependency array.","line":47,"column":6,"nodeType":"ArrayExpression","endLine":47,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [assets]","fix":{"range":[2272,2309],"text":"[assets]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":47,"column":7,"nodeType":"CallExpression","endLine":47,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2796,2799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2796,2799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3295,3298],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3295,3298],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3344,3347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3344,3347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3386,3389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3386,3389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3428,3431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3428,3431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":97,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'FINAL_STATUSES'. Either include it or remove the dependency array.","line":100,"column":6,"nodeType":"ArrayExpression","endLine":100,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [FINAL_STATUSES]","fix":{"range":[4536,4538],"text":"[FINAL_STATUSES]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":120,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'FINAL_STATUSES'. Either include it or remove the dependency array.","line":123,"column":6,"nodeType":"ArrayExpression","endLine":123,"endColumn":68,"suggestions":[{"desc":"Update the dependencies array to be: [loadingMore, hasMore, filterSymbol, nextCursor, historyItems, FINAL_STATUSES]","fix":{"range":[5555,5617],"text":"[loadingMore, hasMore, filterSymbol, nextCursor, historyItems, FINAL_STATUSES]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":170,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":15}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { Tabs, Paper, Group, Select, Title, Loader, Table, ScrollArea, Alert, Badge, Stack, Text, ActionIcon, Tooltip } from '@mantine/core';\nimport { getOrdersHistory, type OrderResponse, cancelOrder } from '../services/restClient';\nimport { useUserStream } from '../store/userStream';\nimport { FreshnessBadge } from './FreshnessBadge';\nimport { useAssets } from '../hooks/useAssets';\nimport { IconReload, IconX } from '@tabler/icons-react';\n\n// No props needed - component now uses only WebSocket for real-time updates\ninterface OrdersPanelProps {}\n\n// Status -> kolor mantine\nconst statusColorMap: Record<string, string> = {\n  NEW: 'blue',\n  FILLED: 'teal',\n  PARTIALLY_FILLED: 'orange',\n  CANCELED: 'red',\n  EXPIRED: 'gray',\n};\n\nconst numberFmt = new Intl.NumberFormat('pl-PL', { minimumFractionDigits: 2, maximumFractionDigits: 8 });\nconst timeFmt = (ts: number) => new Date(ts).toLocaleString('pl-PL');\n\nconst OrdersPanel: React.FC<OrdersPanelProps> = () => {\n  const [tab, setTab] = useState<string>('open');\n  const [filterSymbol, setFilterSymbol] = useState<string | null>(null); // null = ALL (lazy)\n  const { state: userState, sendResnapshot, addOptimisticCancel } = useUserStream();\n  const [historyItems, setHistoryItems] = useState<OrderResponse[]>([]);\n  const [nextCursor, setNextCursor] = useState<number | null>(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [loadingOpen, setLoadingOpen] = useState(false);\n  const [loadingHistory, setLoadingHistory] = useState(false);\n  const [loadingMore, setLoadingMore] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [errorMore, setErrorMore] = useState<string | null>(null);\n  const [cancellingId, setCancellingId] = useState<number | null>(null);\n  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);\n  // Finalne statusy do deduplikacji\n  const FINAL_STATUSES = ['FILLED','CANCELED','REJECTED','EXPIRED'];\n\n  const { assets } = useAssets();\n  // Stabilizuj listę symboli – zmieniaj tylko gdy faktycznie lista (a nie ceny) się zmieni\n  const symbols = useMemo(() => {\n    const set = Array.from(new Set(assets.map(a => a.symbol)));\n    set.sort();\n    return set;\n  }, [assets.map(a => a.symbol).join(',')]);\n  const filterOptions = useMemo(() => (\n    [{ value: 'ALL', label: 'Wszystkie' }, ...symbols.map(s => ({ value: s, label: s }))]\n  ), [symbols]);\n\n  // Pobierz otwarte zlecenia dla wszystkich (API bez parametru zwraca wszystkie dla konta)\n  // open orders pobieramy z user stream state\n  const openOrders: OrderResponse[] = useMemo(() => {\n    const arr = Object.values(userState.openOrders || {});\n      return arr.map(o => ({\n        orderId: o.orderId,\n        orderListId: (o as any).orderListId,\n        clientOrderId: o.clientOrderId || '',\n        symbol: o.symbol,\n        side: o.side,\n        type: o.type || '',\n        price: o.price || '0',\n        origQty: o.origQty || '0',\n        executedQty: o.executedQty || '0',\n        cummulativeQuoteQty: o.cummulativeQuoteQty || '0',\n        status: o.status,\n        timeInForce: o.timeInForce || '',\n        time: o.updateTime || Date.now(),\n        updateTime: o.updateTime || Date.now(),\n        origQuoteOrderQty: (o as any).origQuoteOrderQty,\n        stopPrice: (o as any).stopPrice,\n        icebergQty: (o as any).icebergQty,\n        isWorking: (o as any).isWorking,\n      }));\n  }, [userState.openOrders]);\n\n  // Pobierz historię dla wszystkich symboli sekwencyjnie (lub równolegle Promise.all)\n  // Pobierz pierwszą stronę historii\n  const loadHistoryForSymbol = useCallback(async (symbol: string) => {\n    setLoadingHistory(true); setError(null);\n    try {\n      const res = await getOrdersHistory(symbol, 50); // pierwsza strona\n      const list = res?.orders || [];\n      // Dedup: orderId + finalStatus\n      const dedupMap = new Map<string, OrderResponse>();\n      list.forEach(o => {\n        const key = `${o.orderId}:${FINAL_STATUSES.includes(o.status) ? o.status : ''}`;\n        if (!dedupMap.has(key)) dedupMap.set(key, o);\n      });\n      const deduped = Array.from(dedupMap.values());\n      deduped.sort((a, b) => b.time - a.time);\n      setHistoryItems(deduped);\n      setNextCursor(deduped.length > 0 ? deduped[deduped.length-1].orderId : null);\n      setHasMore(list.length === 50);\n      setLastRefresh(new Date());\n    } catch (e) {\n      setError('Błąd podczas pobierania historii zleceń');\n    } finally { setLoadingHistory(false); }\n  }, []);\n\n  // Pobierz kolejną porcję historii (paginacja)\n  const fetchMoreHistory = useCallback(async () => {\n    if (loadingMore || !hasMore || !filterSymbol) return;\n    setLoadingMore(true); setErrorMore(null);\n    try {\n      const res = await getOrdersHistory(filterSymbol, 50, nextCursor || undefined);\n      const list = res?.orders || [];\n      // Dedup: orderId + finalStatus\n      const dedupMap = new Map<string, OrderResponse>();\n      [...historyItems, ...list].forEach(o => {\n        const key = `${o.orderId}:${FINAL_STATUSES.includes(o.status) ? o.status : ''}`;\n        if (!dedupMap.has(key)) dedupMap.set(key, o);\n      });\n      const deduped = Array.from(dedupMap.values());\n      deduped.sort((a, b) => b.time - a.time);\n      setHistoryItems(deduped);\n      setNextCursor(list.length > 0 ? list[list.length-1].orderId : nextCursor);\n      setHasMore(list.length === 50);\n    } catch (e) {\n      setErrorMore('Błąd podczas ładowania starszych zleceń');\n    } finally { setLoadingMore(false); }\n  }, [loadingMore, hasMore, filterSymbol, nextCursor, historyItems]);\n\n  // Oddzielne efekty aby zmiana symboli (przez tickery) nie wywoływała ponownie loadOpen\n  useEffect(() => {\n    if (tab === 'open') {\n      setLoadingOpen(false);\n      setLastRefresh(new Date());\n    }\n  }, [tab, userState.openOrders]);\n\n  useEffect(() => {\n    if (tab === 'history') {\n      if (filterSymbol && filterSymbol !== 'ALL') {\n        loadHistoryForSymbol(filterSymbol);\n      } else {\n        setHistoryItems([]);\n        setNextCursor(null);\n        setHasMore(false);\n      }\n    }\n  }, [tab, filterSymbol, loadHistoryForSymbol]);\n\n  // Disable legacy polling (interval removed)\n\n  const handleManualRefresh = (() => {\n    let last = 0;\n    return () => {\n      const now = Date.now();\n      if (now - last < 5000) return; // throttle resnapshot to 5s (Phase 7 requirement)\n      last = now;\n      sendResnapshot();\n    };\n  })();\n\n  const handleCancel = async (order: OrderResponse) => {\n    setCancellingId(order.orderId);\n    setError(null);\n    \n    try {\n      // Optymistyczne oznaczenie jako CANCELED\n      addOptimisticCancel(order.orderId, 10000); // 10s timeout dla rollback\n      \n      const resp = await cancelOrder(order.orderId, order.symbol);\n      if (resp?.error) {\n        setError(resp.error);\n        // Uwaga: Rollback zostanie wykonany automatycznie po timeout jeśli nie przyjdzie delta\n      }\n    } catch (e) {\n      setError('Błąd anulowania zlecenia');\n      // Uwaga: Rollback zostanie wykonany automatycznie po timeout jeśli nie przyjdzie delta\n    } finally { \n      setCancellingId(null); \n    }\n  };\n\n  const applyFilter = (orders: OrderResponse[]) => {\n    if (!filterSymbol || filterSymbol === 'ALL') return orders; // open orders może być filtrowane globalnie\n    return orders.filter(o => o.symbol === filterSymbol);\n  };\n\n  const renderRows = (orders: OrderResponse[], showStatus: boolean, allowCancel: boolean) => {\n    const filtered = applyFilter(orders);\n    if (!filtered.length) {\n      return (\n        <Table.Tr>\n          <Table.Td colSpan={allowCancel ? 9 : showStatus ? 8 : 7}>\n            <Text ta=\"center\" c=\"dimmed\">Brak zleceń</Text>\n          </Table.Td>\n        </Table.Tr>\n      );\n    }\n    return filtered.map(o => (\n      <Table.Tr key={`${o.symbol}-${o.orderId}-${FINAL_STATUSES.includes(o.status) ? o.status : ''}`}>\n        <Table.Td>{o.symbol}</Table.Td>\n        <Table.Td>{o.type}</Table.Td>\n        <Table.Td c={o.side === 'BUY' ? 'teal' : 'red'} fw={500}>{o.side}</Table.Td>\n        <Table.Td ta=\"right\" ff=\"monospace\">{numberFmt.format(parseFloat(o.price || '0'))}</Table.Td>\n        <Table.Td ta=\"right\" ff=\"monospace\">{numberFmt.format(parseFloat(o.origQty || '0'))}</Table.Td>\n        <Table.Td ta=\"right\" ff=\"monospace\">{numberFmt.format(parseFloat(o.executedQty || '0'))}</Table.Td>\n        {showStatus && (\n          <Table.Td>\n            <Badge color={statusColorMap[o.status] || 'gray'} variant=\"light\" size=\"sm\">{o.status}</Badge>\n          </Table.Td>\n        )}\n        <Table.Td>{timeFmt(o.time)}</Table.Td>\n        {allowCancel && (\n          <Table.Td>\n            <Tooltip label=\"Anuluj zlecenie\">\n              <ActionIcon variant=\"subtle\" color=\"red\" size=\"sm\" onClick={() => handleCancel(o)} loading={cancellingId === o.orderId}>\n                <IconX size={14} />\n              </ActionIcon>\n            </Tooltip>\n          </Table.Td>\n        )}\n      </Table.Tr>\n    ));\n  };\n\n  const filterLabel = filterSymbol && filterSymbol !== 'ALL' ? ` (filtr: ${filterSymbol})` : '';\n\n  return (\n    <Stack p=\"md\" gap=\"md\">\n      <Group justify=\"space-between\" align=\"center\">\n        <Title order={2}>Zarządzanie Zleceniami</Title>\n        <Group gap=\"xs\">\n          <Select\n            data={filterOptions}\n            value={filterSymbol || 'ALL'}\n            onChange={v => setFilterSymbol(v === 'ALL' ? null : v)}\n            placeholder=\"Filtr Symbolu\"\n            searchable\n            w={200}\n            label=\"Filtr Symbolu\"\n            data-testid=\"filter-select\"\n          />\n          <Tooltip label=\"Odśwież\">\n            <ActionIcon variant=\"light\" onClick={handleManualRefresh}>\n              <IconReload size={16} />\n            </ActionIcon>\n          </Tooltip>\n        </Group>\n      </Group>\n\n      {error && (\n        <Alert color=\"red\" variant=\"light\" withCloseButton onClose={() => setError(null)} title=\"Błąd\">\n          {error}\n        </Alert>\n      )}\n\n      <Tabs value={tab} onChange={(v) => setTab(v || 'open')} keepMounted={false}>\n        <Tabs.List>\n          <Tabs.Tab value=\"open\">Otwarte Zlecenia</Tabs.Tab>\n          <Tabs.Tab value=\"history\">Historia Zleceń</Tabs.Tab>\n        </Tabs.List>\n\n        <Tabs.Panel value=\"open\" pt=\"md\">\n          <Paper withBorder p=\"sm\">\n            <Group justify=\"space-between\" mb=\"sm\">\n              <Group gap={6}>\n                <Title order={4}>Otwarte Zlecenia{filterLabel}</Title>\n                {loadingOpen && <Loader size=\"sm\" />}\n              </Group>\n               {lastRefresh && (\n                 <FreshnessBadge \n                   freshnessMs={userState.freshnessMs ?? 0}\n                   fallback={userState.fallback === true}\n                 />\n               )}\n            </Group>\n            <ScrollArea h={360} type=\"auto\">\n              <Table striped highlightOnHover withTableBorder withColumnBorders>\n                <Table.Thead>\n                  <Table.Tr>\n                    <Table.Th>Symbol</Table.Th>\n                    <Table.Th>Typ</Table.Th>\n                    <Table.Th>Strona</Table.Th>\n                    <Table.Th ta=\"right\">Cena</Table.Th>\n                    <Table.Th ta=\"right\">Ilość</Table.Th>\n                    <Table.Th ta=\"right\">Wykonano</Table.Th>\n                    <Table.Th>Czas</Table.Th>\n                    <Table.Th>Akcje</Table.Th>\n                  </Table.Tr>\n                </Table.Thead>\n                <Table.Tbody>\n                  {loadingOpen ? (\n                    <Table.Tr><Table.Td colSpan={8}><Group justify=\"center\"><Loader /></Group></Table.Td></Table.Tr>\n                  ) : (\n                    renderRows(openOrders, false, true)\n                  )}\n                </Table.Tbody>\n              </Table>\n            </ScrollArea>\n          </Paper>\n        </Tabs.Panel>\n\n        <Tabs.Panel value=\"history\" pt=\"md\">\n          <Paper withBorder p=\"sm\">\n            <Group justify=\"space-between\" mb=\"sm\">\n              <Group gap={6}>\n                <Title order={4}>Historia Zleceń{filterLabel}</Title>\n                {loadingHistory && <Loader size=\"sm\" />}\n              </Group>\n              {lastRefresh && historyItems.length > 0 && <Text size=\"xs\" c=\"dimmed\">Odświeżono: {lastRefresh.toLocaleTimeString()}</Text>}\n            </Group>\n            <ScrollArea h={360} type=\"auto\">\n              <Table striped highlightOnHover withTableBorder withColumnBorders>\n                <Table.Thead>\n                  <Table.Tr>\n                    <Table.Th>Symbol</Table.Th>\n                    <Table.Th>Typ</Table.Th>\n                    <Table.Th>Strona</Table.Th>\n                    <Table.Th ta=\"right\">Cena</Table.Th>\n                    <Table.Th ta=\"right\">Ilość</Table.Th>\n                    <Table.Th ta=\"right\">Wykonano</Table.Th>\n                    <Table.Th>Status</Table.Th>\n                    <Table.Th>Czas</Table.Th>\n                  </Table.Tr>\n                </Table.Thead>\n                <Table.Tbody>\n                  {filterSymbol === null || filterSymbol === 'ALL' ? (\n                    <Table.Tr><Table.Td colSpan={8}><Text ta=\"center\" c=\"dimmed\">Wybierz symbol aby załadować historię (brak masowego pobierania wszystkich par)</Text></Table.Td></Table.Tr>\n                  ) : loadingHistory ? (\n                    <Table.Tr><Table.Td colSpan={8}><Group justify=\"center\"><Loader /></Group></Table.Td></Table.Tr>\n                  ) : (\n                    renderRows(historyItems, true, false)\n                  )}\n                </Table.Tbody>\n              </Table>\n            </ScrollArea>\n            {/* Przycisk \"Załaduj więcej\" */}\n            {filterSymbol && filterSymbol !== 'ALL' && historyItems.length > 0 && hasMore && (\n              <Group justify=\"center\" mt=\"md\">\n                <button\n                  disabled={loadingMore || !hasMore}\n                  style={{ padding: '8px 24px', borderRadius: 6, background: '#eee', cursor: loadingMore || !hasMore ? 'not-allowed' : 'pointer', fontWeight: 500 }}\n                  onClick={fetchMoreHistory}\n                >\n                  {loadingMore ? 'Ładowanie...' : 'Załaduj więcej'}\n                </button>\n              </Group>\n            )}\n            {errorMore && (\n              <Group justify=\"center\" mt=\"xs\"><Text c=\"red\" size=\"sm\">{errorMore}</Text></Group>\n            )}\n          </Paper>\n        </Tabs.Panel>\n      </Tabs>\n    </Stack>\n  );\n};\n\nexport default OrdersPanel;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/PortfolioTable.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/PortfolioTable.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4312,4315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4312,4315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7850,7853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7850,7853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10545,10548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10545,10548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":310,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10613,10616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10613,10616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":311,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10673,10676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10673,10676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":315,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10931,10934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10931,10934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11028,11031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11028,11031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11059,11062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11059,11062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":326,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11353,11356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11353,11356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":333,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11710,11713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11710,11713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":333,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11734,11737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11734,11737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12433,12436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12433,12436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":353,"column":14,"nodeType":"MemberExpression","endLine":353,"endColumn":38},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":353,"column":40,"nodeType":"CallExpression","endLine":353,"endColumn":59}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useEffect, memo } from 'react';\nimport {\n  Text,\n  Table,\n  Paper,\n  Group,\n  Loader,\n  Badge,\n  ActionIcon,\n  Box,\n  Switch,\n  Button,\n  Stack,\n  Progress,\n  Select,\n  TextInput,\n  Tabs,\n  Tooltip,\n} from '@mantine/core';\nimport { \n  getCoreRowModel, \n  flexRender, \n  createColumnHelper, \n  useReactTable,\n  getSortedRowModel,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  type SortingState,\n  type ColumnFiltersState,\n} from '@tanstack/react-table';\nimport { IconRefresh, IconSearch, IconSortAscending, IconSortDescending, IconEye, IconEyeOff } from '@tabler/icons-react';\nimport { PriceCell } from './shared';\nimport type { PortfolioBalance, PortfolioTableProps } from '../types/portfolio';\nimport { useDebounced } from '../hooks/useDebounced';\nimport { usePriceChangeAnimation } from '../hooks/usePriceChangeAnimation';\nimport { formatCurrency, formatCrypto } from '../types/portfolio';\n\nconst columnHelper = createColumnHelper<PortfolioBalance>();\n\nconst PortfolioTable: React.FC<PortfolioTableProps> = ({\n  balances,\n  loading = false,\n  error = null,\n  onRefresh,\n  hideZeroBalances = true,\n  onHideZeroBalancesChange,\n}) => {\n  // Stan dla sortowania, filtrowania i paginacji\n  const [sorting, setSorting] = useState<SortingState>([\n    { id: 'valueUSD', desc: true } // Sortuj po wartości domyślnie\n  ]);\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [globalFilter, setGlobalFilter] = useState('');\n  const [pagination, setPagination] = useState({\n    pageIndex: 0,\n    pageSize: 10,\n  });\n\n  // Debounced search dla lepszej wydajności\n  const debouncedGlobalFilter = useDebounced(globalFilter, 300);\n\n  // Zakładki kategorii: ALL | CRYPTO | STABLE | FIAT\n  type View = 'ALL' | 'CRYPTO' | 'STABLE' | 'FIAT';\n  const [view, setView] = useState<View>('ALL');\n\n  // Zbiory klasyfikacji\n  const STABLECOINS = useMemo(() => new Set([\n    'USDT','USDC','BUSD','TUSD','USDP','DAI','FDUSD','EURT','PYUSD','USDD','GUSD'\n  ]), []);\n  // Rozszerzona lista fiat (kody ISO + spotykane na Binance w saldach)\n  const FIAT_ASSETS = useMemo(() => new Set([\n    'USD','EUR','GBP','PLN','JPY','CNY','TRY','BRL','ARS','MXN','ZAR','UAH','RON','KZT','NGN',\n    'CZK','CHF','SEK','NOK','DKK','HUF','AUD','NZD','CAD','HKD','SGD','COP','CLP','PEN','PHP',\n    'IDR','INR','THB','VND','ILS','AED','SAR','QAR','KRW','MYR'\n  ]), []);\n\n  // Klasyfikacja balansów (dodajemy pole category)\n  const classifiedBalances = useMemo(() => {\n    if (!Array.isArray(balances)) return [] as (PortfolioBalance & { category: View })[];\n    return balances.map(b => {\n      const asset = (b.asset || '').toUpperCase();\n      let category: View = 'CRYPTO';\n      if (STABLECOINS.has(asset)) category = 'STABLE';\n      else if (FIAT_ASSETS.has(asset)) category = 'FIAT';\n      else {\n        // Heurystyka: brak ceny + 3 litery + valueUSD 0 => prawdopodobnie fiat\n        const noPrice = !b.currentPrice || b.currentPrice === 0;\n        if (noPrice && asset.length === 3 && (b.valueUSD === 0 || b.valueUSD === undefined)) {\n          category = 'FIAT';\n        }\n      }\n      return { ...b, category };\n    });\n  }, [balances, STABLECOINS, FIAT_ASSETS]);\n  \n  // Hook do animacji zmian cen\n  const priceChanges = usePriceChangeAnimation(\n    Array.isArray(classifiedBalances) ? classifiedBalances.map(b => ({ symbol: b.asset, price: b.currentPrice || 0 })) : []\n  );\n\n  // Filter balances based on hideZeroBalances setting\n  const filteredBalances = useMemo(() => {\n    let list = classifiedBalances;\n    if (hideZeroBalances) {\n      list = list.filter(balance => balance.total > 0.00000001);\n    }\n    if (view !== 'ALL') {\n      list = list.filter(b => b.category === view);\n    }\n    return list;\n  }, [classifiedBalances, hideZeroBalances, view]);\n\n  // Calculate total portfolio value for percentage calculations\n  const totalPortfolioValue = useMemo(() => {\n    return filteredBalances.reduce((sum, balance) => sum + (balance.valueUSD || 0), 0);\n  }, [filteredBalances]);\n\n  // Definicja kolumn dla tabeli\n  const columns = useMemo(\n    () => [\n      columnHelper.accessor('asset', {\n        header: 'Aktywo',\n        cell: (info) => {\n          const asset = info.getValue();\n          const balance = info.row.original;\n          const category = (balance as any).category as View;\n          const isFiat = category === 'FIAT';\n          const isStable = category === 'STABLE';\n          const micaCompliance = balance.micaCompliance;\n          \n          return (\n            <Group gap=\"xs\">\n              <Text data-testid={`asset-${asset}`} fw={600} c={isFiat ? 'orange' : isStable ? 'teal' : 'blue'} size=\"sm\">\n                {asset}\n              </Text>\n              {isFiat && (\n                <Tooltip label=\"Fiat – brak live wyceny\" withArrow>\n                  <Badge size=\"xs\" color=\"gray\" variant=\"light\">FIAT</Badge>\n                </Tooltip>\n              )}\n              {isStable && (\n                <Tooltip label=\"Stablecoin\" withArrow>\n                  <Badge size=\"xs\" color=\"teal\" variant=\"light\">STB</Badge>\n                </Tooltip>\n              )}\n              {micaCompliance && micaCompliance.status !== 'UNKNOWN' && (\n                <Tooltip \n                  label={`${micaCompliance.recommendation}${micaCompliance.delistingDate ? ` (${micaCompliance.delistingDate})` : ''}`} \n                  withArrow\n                  multiline\n                  w={300}\n                >\n                  <Badge \n                    size=\"xs\" \n                    color={micaCompliance.status === 'COMPLIANT' ? 'green' : 'red'} \n                    variant=\"light\"\n                  >\n                    {micaCompliance.status === 'COMPLIANT' ? 'MiCA ✓' : 'EU ⚠'}\n                  </Badge>\n                </Tooltip>\n              )}\n            </Group>\n          );\n        },\n      }),\n      columnHelper.accessor('free', {\n        header: () => (\n          <Tooltip label=\"Dostępne środki do handlu (nie zawiera zablokowanych w zleceniach)\" withArrow>\n            <Text component=\"span\" style={{ textDecoration: 'underline dotted' }}>\n              Dostępne\n            </Text>\n          </Tooltip>\n        ),\n        cell: (info) => (\n          <Text ta=\"right\" ff=\"monospace\" size=\"sm\" c=\"teal\">\n            {formatCrypto(info.getValue(), 8)}\n          </Text>\n        ),\n      }),\n      columnHelper.accessor('locked', {\n        header: () => (\n          <Tooltip label=\"Środki zablokowane w aktywnych zleceniach\" withArrow>\n            <Text component=\"span\" style={{ textDecoration: 'underline dotted' }}>\n              Zablokowane\n            </Text>\n          </Tooltip>\n        ),\n        cell: (info) => {\n          const value = info.getValue();\n          if (value === 0) {\n            return <Text ta=\"right\" ff=\"monospace\" size=\"sm\" c=\"dimmed\">-</Text>;\n          }\n          return (\n            <Text ta=\"right\" ff=\"monospace\" size=\"sm\" c=\"orange\">\n              {formatCrypto(value, 8)}\n            </Text>\n          );\n        },\n      }),\n      columnHelper.accessor('total', {\n        header: () => (\n          <Tooltip label=\"Łączne saldo (dostępne + zablokowane)\" withArrow>\n            <Text component=\"span\" style={{ textDecoration: 'underline dotted' }}>\n              Łącznie\n            </Text>\n          </Tooltip>\n        ),\n        cell: (info) => (\n          <Text ta=\"right\" ff=\"monospace\" size=\"sm\" fw={600}>\n            {formatCrypto(info.getValue(), 8)}\n          </Text>\n        ),\n      }),\n      columnHelper.accessor('currentPrice', {\n        header: 'Cena',\n        cell: (info) => {\n          const asset = info.row.original.asset;\n          const change = priceChanges.get(asset);\n          const price = info.getValue();\n          \n          if (!price || price === 0) {\n            const cat = (info.row.original as any).category as View;\n            return (\n              <Tooltip label={cat === 'FIAT' ? 'Fiat – wycena niedostępna' : 'Brak danych ceny'} withArrow>\n                <Text c=\"dimmed\" size=\"sm\">-</Text>\n              </Tooltip>\n            );\n          }\n          \n          return (\n            <PriceCell \n              price={price}\n              change={change || undefined}\n              isUSDT={asset === 'USDT'}\n            />\n          );\n        },\n  sortingFn: 'basic',\n      }),\n      columnHelper.accessor('valueUSD', {\n        header: 'Wartość USD',\n        cell: (info) => {\n          const value = info.getValue();\n          if (!value || value === 0) {\n            return <Text c=\"dimmed\" size=\"sm\">$0.00</Text>;\n          }\n          return (\n            <Text ta=\"right\" ff=\"monospace\" fw={500} size=\"sm\">\n              {formatCurrency(value, 'USD')}\n            </Text>\n          );\n        },\n  sortingFn: 'basic',\n      }),\n      // Kolumna udziału procentowego w portfelu – teraz sortowalna\n      columnHelper.accessor(\n        row => {\n          const value = row.valueUSD || 0;\n          if (totalPortfolioValue === 0) return 0;\n            return (value / totalPortfolioValue) * 100;\n        },\n        {\n          id: 'allocation',\n          header: '%',\n          enableSorting: true,\n          // Funkcja sortująca – proste porównanie numeryczne\n          sortingFn: 'basic',\n          cell: (info) => {\n            const percentage = info.getValue<number>() || 0;\n            return (\n              <Box style={{ minWidth: 60 }}>\n                <Text size=\"xs\" c=\"dimmed\" mb={2}>\n                  {percentage.toFixed(1)}%\n                </Text>\n                <Progress\n                  value={percentage}\n                  size=\"xs\"\n                  color={percentage > 10 ? 'blue' : percentage > 5 ? 'teal' : 'gray'}\n                />\n              </Box>\n            );\n          },\n        }\n      ),\n    ],\n    [priceChanges, totalPortfolioValue]\n  );\n\n  // Konfiguracja tabeli TanStack\n  const baseGetSortedRowModel = getSortedRowModel();\n  const table = useReactTable({\n    data: filteredBalances,\n    columns,\n    state: {\n      sorting,\n      columnFilters,\n      globalFilter: debouncedGlobalFilter,\n      pagination,\n    },\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: (value) => {\n      setGlobalFilter(value as string);\n      // Po zmianie wyszukiwarki przejdź na pierwszą stronę, żeby uniknąć pustego widoku\n      setPagination(prev => ({ ...prev, pageIndex: 0 }));\n    },\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    getSortedRowModel: ((table: any) => {\n      const sortedModel = baseGetSortedRowModel(table) as any;\n      const sortingState = table.getState().sorting as any[];\n      if (!sortingState.length) return sortedModel;\n      const colId = sortingState[sortingState.length - 1].id;\n  if (!['currentPrice','valueUSD','allocation','priceChange24h','valueChange24h'].includes(colId)) return sortedModel;\n      const rows: any[] = sortedModel.rows || [];\n      if (!rows.length) return sortedModel;\n      const nonZero: any[] = [];\n      const zeros: any[] = [];\n      for (const r of rows) {\n        const raw = r.getValue(colId);\n        const v = typeof raw === 'number' ? raw : parseFloat(raw);\n        if (!v) zeros.push(r); else nonZero.push(r);\n      }\n      sortedModel.rows = [...nonZero, ...zeros];\n      return sortedModel;\n    }) as any,\n    getFilteredRowModel: getFilteredRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    // Zapobiegnij skakaniu na pierwszą stronę przy każdej aktualizacji cen\n    autoResetPageIndex: false,\n    // Stabilne ID wiersza – aktywo jest unikalne\n    getRowId: (row) => row.asset,\n  debugTable: (typeof process !== 'undefined' && (process as any).env && (process as any).env.NODE_ENV === 'development') || false,\n  });\n\n  // Post-processing: przenieś wiersze z zerową wartością/ceną/udziałem na dół niezależnie od kierunku\n  const displayRows = useMemo(() => {\n    const sortingState = table.getState().sorting;\n    if (!sortingState.length) return table.getRowModel().rows;\n    const colId = sortingState[sortingState.length - 1].id;\n    if (!['currentPrice','valueUSD','allocation','priceChange24h','valueChange24h'].includes(colId)) {\n      return table.getRowModel().rows;\n    }\n    const rows = table.getRowModel().rows;\n    const nonZero: typeof rows = [];\n    const zeros: typeof rows = [];\n    for (const r of rows) {\n      const raw = r.getValue(colId) as any;\n      const v = typeof raw === 'number' ? raw : parseFloat(raw);\n      if (!v) zeros.push(r); else nonZero.push(r);\n    }\n    return [...nonZero, ...zeros];\n  }, [table, table.getState().sorting, table.getRowModel()]);\n\n  // Korekta pageIndex jeśli po zmianie liczby elementów wskazuje poza zakresem\n  useEffect(() => {\n    const pageCount = table.getPageCount();\n    setPagination(prev => {\n      if (prev.pageIndex > 0 && prev.pageIndex >= pageCount) {\n        return { ...prev, pageIndex: Math.max(0, pageCount - 1) };\n      }\n      return prev;\n    });\n  }, [filteredBalances.length, pagination.pageSize, table]);\n\n  if (loading) {\n    return (\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"center\">\n          <Loader size=\"md\" />\n          <Text>Ładowanie portfolio...</Text>\n        </Group>\n      </Paper>\n    );\n  }\n\n  if (error) {\n    return (\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"center\" c=\"red\">\n          <Text>Błąd: {error}</Text>\n          {onRefresh && (\n            <ActionIcon variant=\"outline\" color=\"red\" onClick={onRefresh}>\n              <IconRefresh size={16} />\n            </ActionIcon>\n          )}\n        </Group>\n      </Paper>\n    );\n  }\n\n  const filteredCount = table.getFilteredRowModel().rows.length;\n  const totalCount = classifiedBalances.length;\n\n  return (\n    <Stack gap=\"md\">\n      {/* Kontrolki i statystyki */}\n      <Paper p=\"md\" withBorder>\n        <Stack gap=\"sm\">\n          <Group justify=\"space-between\">\n            <Text size=\"lg\" fw={600}>\n              Portfolio Holdings\n            </Text>\n            <Group gap=\"xs\">\n              <Text size=\"sm\" c=\"dimmed\">\n                {filteredCount} aktywów{(view !== 'ALL' || globalFilter) && ` (z ${totalCount})`}\n              </Text>\n              <Text size=\"sm\" fw={500}>\n                {formatCurrency(totalPortfolioValue)}\n              </Text>\n            </Group>\n          </Group>\n\n          <Tabs value={view} onChange={(v) => setView((v as View) || 'ALL')} keepMounted={false} variant=\"outline\" radius=\"sm\">\n            <Tabs.List>\n              <Tabs.Tab value=\"ALL\">Wszystko</Tabs.Tab>\n              <Tabs.Tab value=\"CRYPTO\">Krypto</Tabs.Tab>\n              <Tabs.Tab value=\"STABLE\">Stablecoiny</Tabs.Tab>\n              <Tabs.Tab value=\"FIAT\">Fiat</Tabs.Tab>\n            </Tabs.List>\n          </Tabs>\n\n          <Group justify=\"space-between\">\n      <TextInput\n              placeholder=\"Szukaj aktywów (np. BTC, ETH...)\"\n              leftSection={<IconSearch size={16} />}\n              value={globalFilter ?? ''}\n              onChange={(event) => {\n                const val = event.currentTarget.value;\n                setGlobalFilter(val);\n                // natychmiast przejdź na pierwszą stronę po zmianie frazy\n                setPagination(prev => ({ ...prev, pageIndex: 0 }));\n        // Przy wyszukiwaniu przechodzimy na ALL aby pokazać wszystkie dopasowania\n        if (val && view !== 'ALL') setView('ALL');\n              }}\n              style={{ flexGrow: 1, maxWidth: 300 }}\n            />\n            \n            <Group gap=\"md\">\n              <Select\n                placeholder=\"Na stronie\"\n                data={[\n                  { value: '10', label: '10' },\n                  { value: '15', label: '15' },\n                  { value: '25', label: '25' },\n                  { value: '50', label: '50' },\n                ]}\n                value={pagination.pageSize.toString()}\n                onChange={(value) =>\n                  setPagination((prev) => ({\n                    ...prev,\n                    pageSize: parseInt(value || '10'),\n                    pageIndex: 0,\n                  }))\n                }\n                w={120}\n              />\n              <Switch\n                checked={hideZeroBalances}\n                onChange={(event) => onHideZeroBalancesChange?.(event.currentTarget.checked)}\n                label=\"Ukryj zero balances\"\n                thumbIcon={hideZeroBalances ? <IconEyeOff size={12} /> : <IconEye size={12} />}\n              />\n              {onRefresh && (\n                <Button\n                  size=\"xs\"\n                  variant=\"outline\"\n                  leftSection={<IconRefresh size={14} />}\n                  onClick={onRefresh}\n                >\n                  Odśwież\n                </Button>\n              )}\n            </Group>\n          </Group>\n        </Stack>\n      </Paper>\n\n      {/* Tabela */}\n      <Paper withBorder>\n        <Table striped highlightOnHover>\n          <Table.Thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <Table.Tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => (\n                  <Table.Th key={header.id}>\n                    {header.isPlaceholder ? null : (\n                      <Group gap=\"xs\">\n                        <Box\n                          style={{ cursor: header.column.getCanSort() ? 'pointer' : 'default' }}\n                          onClick={header.column.getToggleSortingHandler()}\n                        >\n                          {flexRender(\n                            header.column.columnDef.header,\n                            header.getContext()\n                          )}\n                        </Box>\n                        {header.column.getCanSort() && (\n                          <ActionIcon\n                            size=\"xs\"\n                            variant=\"transparent\"\n                            color=\"dimmed\"\n                          >\n                            {header.column.getIsSorted() === 'asc' ? (\n                              <IconSortAscending size={12} />\n                            ) : header.column.getIsSorted() === 'desc' ? (\n                              <IconSortDescending size={12} />\n                            ) : null}\n                          </ActionIcon>\n                        )}\n                      </Group>\n                    )}\n                  </Table.Th>\n                ))}\n              </Table.Tr>\n            ))}\n          </Table.Thead>\n          <Table.Tbody>\n            {table.getRowModel().rows.length === 0 ? (\n              <Table.Tr>\n                <Table.Td colSpan={columns.length}>\n                  <Text ta=\"center\" c=\"dimmed\" py=\"xl\">\n                    Brak aktywów do wyświetlenia\n                  </Text>\n                </Table.Td>\n              </Table.Tr>\n            ) : (\n              displayRows.map((row) => (\n                <Table.Tr key={row.id}>\n                  {row.getVisibleCells().map((cell) => (\n                    <Table.Td key={cell.id}>\n                      {flexRender(cell.column.columnDef.cell, cell.getContext())}\n                    </Table.Td>\n                  ))}\n                </Table.Tr>\n              ))\n            )}\n          </Table.Tbody>\n        </Table>\n\n        {/* Paginacja */}\n        <Group justify=\"space-between\" p=\"md\">\n          <Text size=\"sm\" c=\"dimmed\">\n            Strona {table.getState().pagination.pageIndex + 1} z{' '}\n            {table.getPageCount()} (\n            {table.getFilteredRowModel().rows.length} aktywów)\n          </Text>\n          <Group gap=\"xs\">\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              disabled={!table.getCanPreviousPage()}\n              onClick={() => table.previousPage()}\n            >\n              Poprzednia\n            </Button>\n            <Button\n              size=\"xs\"\n              variant=\"outline\"\n              disabled={!table.getCanNextPage()}\n              onClick={() => table.nextPage()}\n            >\n              Następna\n            </Button>\n          </Group>\n        </Group>\n      </Paper>\n    </Stack>\n  );\n};\n\nexport default memo(PortfolioTable);\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/PriceDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/PriceDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/SimpleBotPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/TradingPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1420,1423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1420,1423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, memo } from 'react';\nimport {\n  Paper,\n  Stack,\n  Group,\n  Text,\n  Title,\n  Button,\n  NumberInput,\n  Select,\n  Alert,\n  Badge,\n  Divider,\n  Grid,\n  Tooltip,\n} from '@mantine/core';\nimport { \n  IconTrendingUp, \n  IconTrendingDown, \n  IconFlask,\n  IconAlertCircle,\n  IconCheck,\n  IconWallet,\n} from '@tabler/icons-react';\nimport { placeOrder, testOrder, type PlaceOrderRequest } from '../services/restClient';\nimport { getCurrentTicker } from '../services/restClient';\nimport { useAssets } from '../hooks/useAssets';\nimport { useUserStream } from '../store/userStream';\nimport { usePortfolio } from '../hooks/usePortfolio';\nimport { formatCrypto } from '../types/portfolio';\n\ninterface TickerData {\n  symbol: string;\n  price: string;\n  change: string;\n  changePercent: string;\n}\n\nconst TradingPanel: React.FC = () => {\n  // Form state\n  const [symbol, setSymbol] = useState('BTCUSDT');\n  const [side, setSide] = useState<'BUY' | 'SELL'>('BUY');\n  const [orderType, setOrderType] = useState<'MARKET' | 'LIMIT'>('MARKET');\n  const [quantity, setQuantity] = useState<number | string>('');\n  const [price, setPrice] = useState<number | string>('');\n  const [timeInForce, setTimeInForce] = useState<'GTC' | 'IOC' | 'FOK'>('GTC');\n\n  // UI state\n  const [loading, setLoading] = useState(false);\n  const [testLoading, setTestLoading] = useState(false);\n  const [result, setResult] = useState<any>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [ticker, setTicker] = useState<TickerData | null>(null);\n\n  // Assets hook for symbol selection and real-time ticker data\n  const { assets } = useAssets();\n  \n  // Portfolio hook for balance information\n  const { balances } = usePortfolio();\n  \n  // User stream for optimistic updates\n  const { addPendingOrder } = useUserStream();\n\n  // Get ticker data from assets instead of polling\n  const currentAsset = assets.find(asset => asset.symbol === symbol);\n  \n  useEffect(() => {\n    if (currentAsset) {\n      setTicker({\n        symbol: currentAsset.symbol,\n        price: currentAsset.price.toString(),\n        change: currentAsset.priceChange?.toString() || '0',\n        changePercent: `${currentAsset.priceChangePercent?.toFixed(2) || '0'}%`\n      });\n    }\n  }, [currentAsset]);\n\n  // Fallback: Load ticker data only once on mount if no WebSocket data\n  useEffect(() => {\n    if (!currentAsset && symbol) {\n      const loadTicker = async () => {\n        try {\n          const tickerData = await getCurrentTicker(symbol);\n          if (tickerData) {\n            setTicker({\n              symbol: tickerData.symbol,\n              price: tickerData.price,\n              change: '0',\n              changePercent: '0%'\n            });\n          }\n        } catch (err) {\n          console.error('Failed to load ticker:', err);\n        }\n      };\n      loadTicker();\n    }\n  }, [symbol, currentAsset]);\n\n  const handleTestOrder = async () => {\n    setTestLoading(true);\n    setError(null);\n    setResult(null);\n\n    try {\n      const orderData: PlaceOrderRequest = {\n        symbol,\n        side,\n        type: orderType,\n        quantity: quantity.toString(),\n        ...(orderType === 'LIMIT' && { price: price.toString() }),\n        timeInForce\n      };\n\n      const response = await testOrder(orderData);\n      \n      if (response.success) {\n        setResult({\n          type: 'test',\n          message: response.message,\n          data: response.test_result\n        });\n      } else {\n        setError(response.error || 'Test order failed');\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Test order failed');\n    } finally {\n      setTestLoading(false);\n    }\n  };\n\n  const handlePlaceOrder = async () => {\n    setLoading(true);\n    setError(null);\n    setResult(null);\n\n    try {\n      const orderData: PlaceOrderRequest = {\n        symbol,\n        side,\n        type: orderType,\n        quantity: quantity.toString(),\n        ...(orderType === 'LIMIT' && { price: price.toString() }),\n        timeInForce\n      };\n\n      // Optymistyczne dodanie zlecenia ze statusem PENDING\n      const optimisticOrder = {\n        orderId: Math.floor(Math.random() * 1000000), // Tymczasowe ID\n        clientOrderId: `optimistic_${Date.now()}`,\n        symbol,\n        side,\n        type: orderType,\n        timeInForce,\n        price: orderType === 'LIMIT' ? price.toString() : ticker?.price || '0',\n        origQty: quantity.toString(),\n        executedQty: '0',\n        cummulativeQuoteQty: '0',\n        avgPrice: '0',\n        status: 'PENDING',\n        updateTime: Date.now(),\n        fills: []\n      };\n      \n      addPendingOrder(optimisticOrder, 5000); // 5s timeout\n\n      const response = await placeOrder(orderData);\n      \n      if (response.success) {\n        setResult({\n          type: 'live',\n          message: 'Order placed successfully!',\n          data: response.order\n        });\n        // Reset form after successful order\n        setQuantity('');\n        setPrice('');\n      } else {\n        setError(response.error || 'Failed to place order');\n        // Note: Optymistyczne zlecenie zostanie automatycznie usunięte po timeout\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to place order');\n      // Note: Optymistyczne zlecenie zostanie automatycznie usunięte po timeout\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const isFormValid = () => {\n    if (!quantity || parseFloat(quantity.toString()) <= 0) return false;\n    if (orderType === 'LIMIT' && (!price || parseFloat(price.toString()) <= 0)) return false;\n    return true;\n  };\n\n  const getEstimatedTotal = () => {\n    if (!quantity) return '0.00';\n    \n    let estimatedPrice = 0;\n    if (orderType === 'LIMIT' && price) {\n      estimatedPrice = parseFloat(price.toString());\n    } else if (ticker?.price) {\n      estimatedPrice = parseFloat(ticker.price);\n    }\n    \n    const qty = parseFloat(quantity.toString());\n    return (qty * estimatedPrice).toFixed(2);\n  };\n\n  const symbolOptions = assets.map(asset => ({\n    value: asset.symbol,\n    label: `${asset.symbol} - ${asset.baseAsset}/${asset.quoteAsset}`\n  }));\n\n  return (\n    <Stack gap=\"md\" p=\"md\">\n      <Title order={2}>Panel Tradingowy</Title>\n      \n      {/* Current Price Display */}\n      {ticker && (\n        <Paper p=\"md\" withBorder>\n          <Group justify=\"space-between\" align=\"center\">\n            <Group gap=\"md\">\n              <Text size=\"xl\" fw={700}>\n                {ticker.symbol}\n              </Text>\n              <Text size=\"lg\" ff=\"monospace\" fw={600}>\n                ${parseFloat(ticker.price).toFixed(2)}\n              </Text>\n            </Group>\n            <Badge color=\"blue\" variant=\"light\">\n              TESTNET\n            </Badge>\n          </Group>\n        </Paper>\n      )}\n      \n      {/* Available Balance Display */}\n      <Paper p=\"md\" withBorder>\n        <Group justify=\"space-between\" align=\"center\">\n          <Group gap=\"md\">\n            <IconWallet size={20} />\n            <Text size=\"md\" fw={600}>\n              Dostępne saldo\n            </Text>\n          </Group>\n          <Group gap=\"lg\">\n            {/* Show USDT balance for all pairs */}\n            <Group gap=\"xs\">\n              <Text size=\"sm\" c=\"dimmed\">USDT:</Text>\n              <Tooltip label=\"Dostępne środki do handlu (nie zawiera zablokowanych w zleceniach)\" withArrow>\n                <Text size=\"sm\" ff=\"monospace\" fw={600} c=\"teal\" style={{ textDecoration: 'underline dotted' }}>\n                  {(() => {\n                    const usdtBalance = balances.find(b => b.asset === 'USDT');\n                    return usdtBalance ? formatCrypto(usdtBalance.free, 2) : '0.00';\n                  })()}\n                </Text>\n              </Tooltip>\n            </Group>\n            \n            {/* Show base asset balance if not USDT */}\n            {symbol && !symbol.endsWith('USDT') && (() => {\n              const baseAsset = symbol.replace('USDT', '');\n              const baseBalance = balances.find(b => b.asset === baseAsset);\n              return baseBalance && baseBalance.free > 0 ? (\n                <Group gap=\"xs\">\n                  <Text size=\"sm\" c=\"dimmed\">{baseAsset}:</Text>\n                  <Tooltip label=\"Dostępne środki do sprzedaży\" withArrow>\n                    <Text size=\"sm\" ff=\"monospace\" fw={600} c=\"blue\" style={{ textDecoration: 'underline dotted' }}>\n                      {formatCrypto(baseBalance.free, 8)}\n                    </Text>\n                  </Tooltip>\n                </Group>\n              ) : null;\n            })()}\n          </Group>\n        </Group>\n      </Paper>\n      \n      <Grid>\n        <Grid.Col span={8}>\n          <Paper p=\"md\" withBorder>\n            <Stack gap=\"md\">\n              <Text size=\"lg\" fw={600}>\n                Nowe Zlecenie\n              </Text>\n              \n              {/* Symbol Selection */}\n              <Select\n                label=\"Symbol\"\n                value={symbol}\n                onChange={(value) => setSymbol(value || 'BTCUSDT')}\n                data={symbolOptions}\n                searchable\n                maxDropdownHeight={200}\n              />\n              \n              {/* Order Type and Side */}\n              <Grid>\n                <Grid.Col span={6}>\n                  <Select\n                    label=\"Typ zlecenia\"\n                    value={orderType}\n                    onChange={(value) => setOrderType(value as 'MARKET' | 'LIMIT')}\n                    data={[\n                      { value: 'MARKET', label: 'Market (natychmiastowe)' },\n                      { value: 'LIMIT', label: 'Limit (z ceną)' }\n                    ]}\n                  />\n                </Grid.Col>\n                <Grid.Col span={6}>\n                  <Select\n                    label=\"Strona\"\n                    value={side}\n                    onChange={(value) => setSide(value as 'BUY' | 'SELL')}\n                    data={[\n                      { value: 'BUY', label: '🟢 Kupno (BUY)' },\n                      { value: 'SELL', label: '🔴 Sprzedaż (SELL)' }\n                    ]}\n                  />\n                </Grid.Col>\n              </Grid>\n              \n              {/* Quantity and Price */}\n              <Grid>\n                <Grid.Col span={orderType === 'LIMIT' ? 6 : 12}>\n                  <NumberInput\n                    label={`Ilość (${symbol.replace('USDT', '')})`}\n                    value={quantity}\n                    onChange={setQuantity}\n                    min={0}\n                    decimalScale={8}\n                    placeholder=\"0.001\"\n                    required\n                  />\n                </Grid.Col>\n                {orderType === 'LIMIT' && (\n                  <Grid.Col span={6}>\n                    <NumberInput\n                      label=\"Cena (USDT)\"\n                      value={price}\n                      onChange={setPrice}\n                      min={0}\n                      decimalScale={2}\n                      placeholder={ticker?.price || '0.00'}\n                      required\n                    />\n                  </Grid.Col>\n                )}\n              </Grid>\n              \n              {/* Time in Force (only for LIMIT orders) */}\n              {orderType === 'LIMIT' && (\n                <Select\n                  label=\"Time in Force\"\n                  value={timeInForce}\n                  onChange={(value) => setTimeInForce(value as 'GTC' | 'IOC' | 'FOK')}\n                  data={[\n                    { value: 'GTC', label: 'GTC - Good Till Canceled' },\n                    { value: 'IOC', label: 'IOC - Immediate or Cancel' },\n                    { value: 'FOK', label: 'FOK - Fill or Kill' }\n                  ]}\n                />\n              )}\n              \n              {/* Estimated Total */}\n              <Paper p=\"sm\" bg=\"gray.0\" withBorder>\n                <Group justify=\"space-between\">\n                  <Text size=\"sm\" c=\"dimmed\">\n                    Szacowana wartość:\n                  </Text>\n                  <Text size=\"sm\" fw={600} ff=\"monospace\">\n                    ${getEstimatedTotal()} USDT\n                  </Text>\n                </Group>\n              </Paper>\n              \n              <Divider />\n              \n              {/* Action Buttons */}\n              <Group gap=\"md\">\n                <Button\n                  leftSection={<IconFlask size={16} />}\n                  variant=\"outline\"\n                  onClick={handleTestOrder}\n                  loading={testLoading}\n                  disabled={!isFormValid() || loading}\n                  flex={1}\n                >\n                  Test Order\n                </Button>\n                <Button\n                  leftSection={side === 'BUY' ? <IconTrendingUp size={16} /> : <IconTrendingDown size={16} />}\n                  color={side === 'BUY' ? 'teal' : 'red'}\n                  onClick={handlePlaceOrder}\n                  loading={loading}\n                  disabled={!isFormValid() || testLoading}\n                  flex={1}\n                >\n                  {side === 'BUY' ? 'Kupuj' : 'Sprzedaj'}\n                </Button>\n              </Group>\n            </Stack>\n          </Paper>\n        </Grid.Col>\n        \n        <Grid.Col span={4}>\n          <Stack gap=\"md\">\n            {/* Quick Actions */}\n            <Paper p=\"md\" withBorder>\n              <Text size=\"md\" fw={600} mb=\"md\">\n                Szybkie akcje\n              </Text>\n              <Stack gap=\"xs\">\n                <Button\n                  size=\"sm\"\n                  variant=\"light\"\n                  onClick={() => {\n                    setQuantity('0.001');\n                    setOrderType('MARKET');\n                    setSide('BUY');\n                  }}\n                >\n                  Kup 0.001 BTC (Market)\n                </Button>\n                <Button\n                  size=\"sm\"\n                  variant=\"light\"\n                  color=\"red\"\n                  onClick={() => {\n                    setQuantity('0.001');\n                    setOrderType('MARKET');\n                    setSide('SELL');\n                  }}\n                >\n                  Sprzedaj 0.001 BTC (Market)\n                </Button>\n                <Button\n                  size=\"sm\"\n                  variant=\"outline\"\n                  onClick={() => {\n                    setQuantity('');\n                    setPrice('');\n                    setOrderType('MARKET');\n                    setSide('BUY');\n                    setError(null);\n                    setResult(null);\n                  }}\n                >\n                  Wyczyść formularz\n                </Button>\n              </Stack>\n            </Paper>\n            \n            {/* Info */}\n            <Paper p=\"md\" withBorder>\n              <Text size=\"sm\" c=\"dimmed\">\n                ⚠️ To jest środowisko testowe Binance. Zlecenia są wykonywane na testnet z wirtualnymi środkami.\n              </Text>\n            </Paper>\n          </Stack>\n        </Grid.Col>\n      </Grid>\n      \n      {/* Results Display */}\n      {error && (\n        <Alert\n          icon={<IconAlertCircle size={16} />}\n          title=\"Błąd\"\n          color=\"red\"\n          onClose={() => setError(null)}\n          withCloseButton\n        >\n          {error}\n        </Alert>\n      )}\n      \n      {result && (\n        <Alert\n          icon={<IconCheck size={16} />}\n          title={result.type === 'test' ? 'Test Order - Sukces' : 'Zlecenie złożone'}\n          color={result.type === 'test' ? 'blue' : 'teal'}\n          onClose={() => setResult(null)}\n          withCloseButton\n        >\n          <Text>{result.message}</Text>\n          {result.data && (\n            <Paper p=\"sm\" mt=\"xs\" bg=\"gray.0\">\n              <Text size=\"xs\" ff=\"monospace\">\n                {JSON.stringify(result.data, null, 2)}\n              </Text>\n            </Paper>\n          )}\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n\nexport default memo(TradingPanel);\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/shared/PriceCell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/shared/TableComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/components/shared/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/config/api.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[100,103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[100,103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[149,152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[149,152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1013,1016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1013,1016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// API Configuration\nconst getBaseUrl = () => {\n  if (typeof process !== 'undefined' && (process as any).env?.VITE_API_URL) {\n    return (process as any).env.VITE_API_URL as string;\n  }\n  return 'http://localhost:8001';\n};\n\nexport const API_CONFIG = {\n  // W środowisku deweloperskim używaj localhost, w produkcji HTTPS\n  BASE_URL: getBaseUrl(),\n  \n  // Endpoints\n  ENDPOINTS: {\n    BOT_CONFIG: '/bot/config',\n    BOT_STRATEGIES: '/bot/strategies',\n    BOT_START: '/bot/start',\n    BOT_STOP: '/bot/stop',\n    BOT_STATUS: '/bot/status',\n    ACCOUNT_INFO: '/account/info',\n    MARKET_DATA: '/market/data',\n  }\n};\n\n// Helper function to build full URL\nexport const buildApiUrl = (endpoint: string): string => {\n  return `${API_CONFIG.BASE_URL}${endpoint}`;\n};\n\n// Secure fetch wrapper\nexport const secureApiCall = async (endpoint: string, options?: RequestInit) => {\n  const url = buildApiUrl(endpoint);\n  \n  // W produkcji, sprawdź czy URL jest HTTPS\n  const isProd = (typeof process !== 'undefined' && (process as any).env?.NODE_ENV === 'production') || false;\n\n  if (isProd && !url.startsWith('https://')) {\n    throw new Error('Production requires HTTPS connections');\n  }\n  \n  return fetch(url, {\n    ...options,\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/config/websocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/data/mockAssets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/__tests__/useChart.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useAssets.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[698,701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[698,701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[820,823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[820,823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_q' is assigned a value but never used.","line":129,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":17}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from 'react';\nimport { fetchAllTradingPairs } from '../services/binanceAPI';\nimport BinanceTickerWSClient from '../services/BinanceTickerWSClient';\nimport type { BinanceTicker24hr } from '../services/BinanceTickerWSClient';\nimport type { Asset } from '../types/asset';\n\nexport interface UseAssetsReturn {\n  assets: Asset[];\n  loading: boolean;\n  error: string | null;\n  refetch: () => void;\n  isConnected: boolean;\n  setPreferredQuotes: (quotes: string[] | null) => void;\n}\n\ntype AssetsState = {\n  assets: Asset[];\n  loading: boolean;\n  error: string | null;\n  isConnected: boolean;\n};\n\nconst MAX_SUBSCRIPTIONS = Number((typeof process !== 'undefined' && (process as any).env?.VITE_MAX_TICKER_SUBS) || 100);\nconst MARKET_QUOTES: string[] = (((typeof process !== 'undefined' && (process as any).env?.VITE_MARKET_QUOTES) || 'USDT,BTC,ETH,BNB'))\n  .split(',')\n  .map((q: string) => q.trim().toUpperCase())\n  .filter(Boolean);\nconst FETCH_COOLDOWN = 60000; // 60s\nconst UPDATE_THROTTLE_MS = 750; // Increased from 500ms to 750ms for better performance\n\nclass AssetStore {\n  state: AssetsState = { assets: [], loading: true, error: null, isConnected: false };\n  subscribers = new Set<(s: AssetsState) => void>();\n  initialized = false;\n  wsClient: BinanceTickerWSClient | null = null;\n  connectionInterval: number | null = null;\n  refreshInterval: number | null = null;\n  lastFetch = 0;\n  pendingTickers = new Map<string, BinanceTicker24hr>();\n  throttleTimer: number | null = null;\n  preferredQuotes: string[] | null = null; // when set, prioritize these quotes for subscriptions\n\n  init() {\n    if (this.initialized) return;\n    this.initialized = true;\n    this.fetchAssets(true);\n\n    // Fallback periodic refresh if WS not connected\n    this.refreshInterval = window.setInterval(() => {\n      const connected = this.wsClient?.isConnected ?? false;\n      if (!connected) this.fetchAssets(false);\n    }, 120000);\n\n    window.addEventListener('beforeunload', () => this.destroy());\n  }\n\n  destroy() {\n    if (this.connectionInterval) {\n      clearInterval(this.connectionInterval);\n      this.connectionInterval = null;\n    }\n    if (this.refreshInterval) {\n      clearInterval(this.refreshInterval);\n      this.refreshInterval = null;\n    }\n    if (this.throttleTimer) {\n      clearTimeout(this.throttleTimer);\n      this.throttleTimer = null;\n    }\n    if (this.wsClient) {\n      this.wsClient.destroy();\n      this.wsClient = null;\n    }\n    this.subscribers.clear();\n    this.initialized = false;\n  }\n\n  notify() {\n    for (const cb of this.subscribers) cb(this.state);\n  }\n\n  async fetchAssets(force = false) {\n    const now = Date.now();\n    if (!force && now - this.lastFetch < FETCH_COOLDOWN) return;\n\n    try {\n      this.state = { ...this.state, loading: true, error: null };\n      this.notify();\n      const data = await fetchAllTradingPairs();\n      this.state = { ...this.state, assets: data, loading: false };\n      this.lastFetch = now;\n      this.notify();\n      if (!this.wsClient) this.initWS();\n      else this.updateSubscriptions();\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : 'Failed to fetch assets';\n      this.state = { ...this.state, error: msg, loading: false };\n      this.notify();\n    }\n  }\n\n  initWS() {\n    if (this.wsClient) return;\n    this.wsClient = new BinanceTickerWSClient();\n    this.wsClient.addListener((tickers) => this.onTickers(tickers));\n    // Connection monitor\n    this.connectionInterval = window.setInterval(() => {\n      const connected = this.wsClient?.isConnected ?? false;\n      if (connected !== this.state.isConnected) {\n        this.state = { ...this.state, isConnected: connected };\n        this.notify();\n      }\n    }, 5000);\n    this.updateSubscriptions();\n  }\n\n  updateSubscriptions() {\n    if (!this.wsClient || this.state.assets.length === 0) return;\n    const allowedQuotes = (this.preferredQuotes && this.preferredQuotes.length > 0)\n      ? this.preferredQuotes.map(q => q.toUpperCase())\n      : MARKET_QUOTES;\n    const candidates = this.state.assets.filter(a => allowedQuotes.includes(a.quoteAsset));\n\n    // równy przydział subskrypcji per rynek, aby nie faworyzować tylko USDT\n    const perQuote = Math.max(1, Math.floor(MAX_SUBSCRIPTIONS / Math.max(1, allowedQuotes.length)));\n    const byQuote = new Map<string, Asset[]>();\n    for (const q of allowedQuotes) byQuote.set(q, []);\n    for (const a of candidates) byQuote.get(a.quoteAsset)?.push(a);\n  for (const [_q, arr] of byQuote) arr.sort((a, b) => b.volume - a.volume);\n\n    const picked: Asset[] = [];\n    for (const q of allowedQuotes) {\n      const arr = byQuote.get(q) || [];\n      picked.push(...arr.slice(0, perQuote));\n    }\n\n    // Jeśli mamy jeszcze wolne sloty, dobij ogólnie wg wolumenu\n    if (picked.length < MAX_SUBSCRIPTIONS) {\n      const pickedSet = new Set(picked.map(a => a.symbol));\n      const remaining = candidates\n        .filter(a => !pickedSet.has(a.symbol))\n        .sort((a, b) => b.volume - a.volume);\n      picked.push(...remaining.slice(0, MAX_SUBSCRIPTIONS - picked.length));\n    }\n\n    const symbols = Array.from(new Set(picked.map(a => a.symbol)));\n    this.wsClient.setSubscriptions(symbols);\n  }\n\n  setPreferredQuotes(quotes: string[] | null) {\n    this.preferredQuotes = quotes && quotes.length ? quotes.map(q => q.toUpperCase()) : null;\n    this.updateSubscriptions();\n  }\n\n  onTickers(tickers: BinanceTicker24hr[]) {\n    for (const t of tickers) this.pendingTickers.set(t.s, t);\n    if (this.throttleTimer === null) {\n      this.throttleTimer = window.setTimeout(() => {\n        this.throttleTimer = null;\n        if (this.pendingTickers.size === 0) return;\n        \n        const updates = new Map(this.pendingTickers);\n        this.pendingTickers.clear();\n        \n        // Optimized: update only changed assets, preserve references for unchanged ones\n        const next = this.state.assets.map(a => {\n          const t = updates.get(a.symbol);\n          if (!t) return a; // Preserve reference for unchanged assets\n          \n          const newPrice = parseFloat(t.c);\n          const newChangePercent = parseFloat(t.P);\n          const newVolume = parseFloat(t.q);\n          const newHighPrice = parseFloat(t.h);\n          const newLowPrice = parseFloat(t.l);\n          \n          // Check if values actually changed to avoid unnecessary object creation\n          if (a.price === newPrice && a.priceChangePercent === newChangePercent && \n              a.volume === newVolume && a.highPrice === newHighPrice && a.lowPrice === newLowPrice) {\n            return a; // No change, preserve reference\n          }\n          \n          return {\n            ...a,\n            price: newPrice,\n            priceChangePercent: newChangePercent,\n            volume: newVolume,\n            highPrice: newHighPrice,\n            lowPrice: newLowPrice,\n          } as Asset;\n        });\n        this.state = { ...this.state, assets: next };\n        this.notify();\n      }, UPDATE_THROTTLE_MS);\n    }\n  }\n}\n\nconst store = new AssetStore();\n\nexport const useAssets = (): UseAssetsReturn => {\n  const [state, setState] = useState<AssetsState>(store.state);\n\n  useEffect(() => {\n    store.init();\n    setState(store.state);\n    const cb = (s: AssetsState) => setState(s);\n    store.subscribers.add(cb);\n    return () => {\n      store.subscribers.delete(cb);\n      // Don't destroy global store on unmount of a single consumer\n    };\n  }, []);\n\n  return {\n    assets: state.assets,\n    loading: state.loading,\n    error: state.error,\n    refetch: () => store.fetchAssets(true),\n    isConnected: state.isConnected,\n  setPreferredQuotes: (quotes: string[] | null) => store.setPreferredQuotes(quotes),\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useChart.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":39,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":39,"endColumn":34,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[841,930],"text":"type SafeChartOptions = ChartOptions"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.","line":130,"column":15,"nodeType":"SpreadElement","endLine":130,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useEffect, useCallback } from 'react';\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  LineController,\n  Title,\n  Tooltip,\n  Legend,\n  Filler\n} from 'chart.js';\nimport type { ChartData, ChartOptions } from 'chart.js';\nimport 'chartjs-adapter-date-fns';\n\n// Zarejestruj komponenty Chart.js\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  TimeScale,\n  PointElement,\n  LineElement,\n  LineController,\n  Title,\n  Tooltip,\n  Legend,\n  Filler\n);\n\nconsole.log('[useChart] Chart.js components registered successfully');\n\n// Type definitions for better type safety\nexport type ChartUpdateMode = 'default' | 'none' | 'resize' | 'reset' | 'show' | 'hide' | 'active';\n\nexport type ChartDataValue = number | { x: number; y: number } | [number, number] | null;\n\nexport interface SafeChartOptions extends ChartOptions {\n  // Add any specific options we need\n}\n\nexport interface ChartConfiguration {\n  type: 'line' | 'bar' | 'pie' | 'doughnut' | 'polarArea' | 'radar' | 'scatter' | 'bubble';\n  data: ChartData;\n  options?: ChartOptions;\n}\n\n// Safety validation functions\nconst validateDatasetIndex = (index: number, datasets: unknown[]): boolean => {\n  return Number.isInteger(index) && index >= 0 && index < datasets.length;\n};\n\nconst isValidChartData = (data: unknown): data is ChartData => {\n  return typeof data === 'object' && data !== null && 'datasets' in data;\n};\n\n/**\n * Custom hook for managing Chart.js instances with proper lifecycle management\n * \n * Features:\n * - Automatic cleanup of previous chart instances\n * - Type-safe Chart.js configuration\n * - Memory leak prevention\n * - Error handling for canvas operations\n * \n * @param config - Chart.js configuration object\n * @param dependencies - Array of dependencies that trigger chart recreation\n * @returns Object containing chartRef for canvas element and chart instance\n */\nexport function useChart(\n  config: ChartConfiguration,\n  dependencies: React.DependencyList = []\n) {\n  const chartRef = useRef<HTMLCanvasElement>(null);\n  const chartInstanceRef = useRef<ChartJS | null>(null);\n  const canvasIdRef = useRef<string>(`chart-${Math.random().toString(36).substr(2, 9)}`);\n\n  useEffect(() => {\n    if (!chartRef.current) {\n      console.warn('[useChart] Canvas ref is not available');\n      return;\n    }\n\n    console.log('[useChart] Creating new Chart.js instance');\n\n    // Always destroy existing chart first and clear canvas completely\n    if (chartInstanceRef.current) {\n      console.log('[useChart] Destroying existing chart instance');\n      try {\n        chartInstanceRef.current.destroy();\n      } catch (error) {\n        console.warn('[useChart] Error destroying existing chart:', error);\n      }\n      chartInstanceRef.current = null;\n    }\n\n    // Ensure canvas has unique ID and clear it\n    const canvas = chartRef.current;\n    canvas.id = canvasIdRef.current;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      // Reset canvas size to trigger complete cleanup\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n    }\n\n    try {\n      // Safe type assertion - ChartConfiguration is compatible with Chart.js config\n      chartInstanceRef.current = new ChartJS(canvas, config);\n      console.log('[useChart] Chart.js instance created successfully');\n    } catch (error) {\n      console.error('[useChart] Error creating chart:', error);\n    }\n\n    return () => {\n      if (chartInstanceRef.current) {\n        console.log('[useChart] Cleanup: destroying chart instance');\n        try {\n          chartInstanceRef.current.destroy();\n        } catch (error) {\n          console.warn('[useChart] Failed to destroy chart instance:', error);\n        } finally {\n          chartInstanceRef.current = null;\n        }\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [config, ...dependencies]);\n\n  // Additional cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (chartInstanceRef.current) {\n        try {\n          chartInstanceRef.current.destroy();\n        } catch (error) {\n          console.warn('[useChart] Failed to destroy chart instance during unmount:', error);\n        } finally {\n          chartInstanceRef.current = null;\n        }\n      }\n    };\n  }, []);\n\n  const updateChart = useCallback((data?: ChartData, options: ChartUpdateMode = 'default') => {\n    if (chartInstanceRef.current) {\n      if (data && isValidChartData(data)) {\n        console.log('[useChart] Updating chart data');\n        chartInstanceRef.current.data = data;\n      }\n      chartInstanceRef.current.update(options);\n    }\n  }, []);\n\n  const updateDataset = useCallback((datasetIndex: number, newData: ChartDataValue[]) => {\n    if (chartInstanceRef.current && chartInstanceRef.current.data.datasets) {\n      if (!validateDatasetIndex(datasetIndex, chartInstanceRef.current.data.datasets)) {\n        console.error(`[useChart] Invalid dataset index: ${datasetIndex}`);\n        return;\n      }\n      \n      console.log(`[useChart] Updating dataset ${datasetIndex} with ${newData.length} points`);\n      chartInstanceRef.current.data.datasets[datasetIndex].data = newData;\n      chartInstanceRef.current.update();\n    }\n  }, []);\n\n  const addDataPoint = useCallback((label: Date | string | number, datasetIndex: number, value: number, maxPoints = 100) => {\n    console.log(`[useChart] Adding data point: label=${String(label)}, value=${value}, datasetIndex=${datasetIndex}`);\n    \n    if (!chartInstanceRef.current || !chartInstanceRef.current.data.datasets) {\n      console.error('[useChart] Chart instance or datasets not available');\n      return;\n    }\n\n    if (!validateDatasetIndex(datasetIndex, chartInstanceRef.current.data.datasets)) {\n      console.error(`[useChart] Invalid dataset index: ${datasetIndex}`);\n      return;\n    }\n    \n    const chart = chartInstanceRef.current;\n    const dataset = chart.data.datasets[datasetIndex];\n    \n    if (!dataset) {\n      console.error(`[useChart] Dataset at index ${datasetIndex} not found`);\n      return;\n    }\n    \n    // Safely add new data\n    if (!chart.data.labels) {\n      chart.data.labels = [];\n    }\n    if (!Array.isArray(dataset.data)) {\n      dataset.data = [];\n    }\n    \n    chart.data.labels.push(label);\n    (dataset.data as ChartDataValue[]).push(value);\n    \n    console.log(`[useChart] Chart data after adding: labels=${chart.data.labels.length}, data=${dataset.data.length}`);\n    \n    // Remove oldest data if exceeding maxPoints\n    if (chart.data.labels.length > maxPoints) {\n      chart.data.labels.shift();\n      (dataset.data as ChartDataValue[]).shift();\n      console.log(`[useChart] Removed old data point, current length: ${chart.data.labels.length}`);\n    }\n    \n    chart.update('none');\n    console.log('[useChart] Chart updated successfully');\n  }, []);\n\n  const clearChart = useCallback(() => {\n    if (chartInstanceRef.current) {\n      console.log('[useChart] Clearing chart data');\n      chartInstanceRef.current.data.labels = [];\n      chartInstanceRef.current.data.datasets.forEach(dataset => {\n        dataset.data = [];\n      });\n      chartInstanceRef.current.update();\n    }\n  }, []);\n\n  return {\n    chartRef,\n    chartInstance: chartInstanceRef.current,\n    updateChart,\n    updateDataset,\n    addDataPoint,\n    clearChart\n  };\n}\n\n/**\n * Type definitions for better TypeScript support\n */\nexport interface ChartHookReturn {\n  chartRef: React.RefObject<HTMLCanvasElement>;\n  chartInstance: ChartJS | null;\n  updateChart: (data?: ChartData, options?: ChartUpdateMode) => void;\n  updateDataset: (datasetIndex: number, newData: ChartDataValue[]) => void;\n  addDataPoint: (label: Date | string | number, datasetIndex: number, value: number, maxPoints?: number) => void;\n  clearChart: () => void;\n}\n\nexport default useChart;","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useChartIndicators.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[706,709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[706,709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1195,1198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1195,1198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1855,1858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1855,1858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2362,2365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2362,2365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3086,3089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3086,3089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3146,3149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3146,3149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3249,3252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3249,3252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3307,3310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3307,3310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3787,3790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3787,3790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4296,4299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4296,4299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4757,4760],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4757,4760],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5457,5460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5457,5460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5588,5591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5588,5591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6177,6180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6177,6180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":225,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6981,6984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6981,6984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7107,7110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7107,7110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7233,7236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7233,7236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useCallback, useState } from 'react';\nimport { LineSeries } from 'lightweight-charts';\nimport type { IChartApi, ISeriesApi, LineData } from 'lightweight-charts';\nimport type { CandleData } from '../indicators';\nimport {\n  calculateRSI,\n  calculateMovingAverage,\n  calculateMACD,\n  calculateBollingerBands,\n  DEFAULT_RSI_CONFIG,\n  DEFAULT_MA_CONFIG,\n  DEFAULT_MACD_CONFIG,\n  DEFAULT_BOLLINGER_BANDS_CONFIG,\n  type RSIConfig,\n  type MovingAverageConfig,\n  type MACDConfig,\n  type BollingerBandsConfig\n} from '../indicators';\n\nexport interface IndicatorSeries {\n  id: string;\n  type: 'RSI' | 'MA' | 'MACD' | 'BB';\n  name: string;\n  series: ISeriesApi<'Line'>[];\n  visible: boolean;\n  config: any;\n}\n\n/**\n * Hook for managing technical indicators on charts\n */\nexport function useChartIndicators(chartInstance: IChartApi | null) {\n  const [indicators, setIndicators] = useState<IndicatorSeries[]>([]);\n  const indicatorsRef = useRef<IndicatorSeries[]>([]);\n\n  // Update ref when indicators change\n  useCallback(() => {\n    indicatorsRef.current = indicators;\n  }, [indicators]);\n\n  // Convert CandlestickData to CandleData format\n  const convertToIndicatorData = useCallback((data: any[]): CandleData[] => {\n    return data.map(item => ({\n      time: typeof item.time === 'number' ? item.time : new Date(item.time).getTime() / 1000,\n      open: typeof item.open === 'number' ? item.open : parseFloat(item.open),\n      high: typeof item.high === 'number' ? item.high : parseFloat(item.high),\n      low: typeof item.low === 'number' ? item.low : parseFloat(item.low),\n      close: typeof item.close === 'number' ? item.close : parseFloat(item.close),\n      volume: item.volume ? (typeof item.volume === 'number' ? item.volume : parseFloat(item.volume)) : undefined\n    }));\n  }, []);\n\n  // Add RSI indicator\n  const addRSI = useCallback((data: any[], config: RSIConfig = DEFAULT_RSI_CONFIG) => {\n    if (!chartInstance) return null;\n\n    const indicatorData = convertToIndicatorData(data);\n    const rsiValues = calculateRSI(indicatorData, config);\n    \n    const rsiSeries = chartInstance.addSeries(LineSeries, {\n      color: '#FF6B35',\n      lineWidth: 2,\n      title: `RSI(${config.period})`,\n      priceScaleId: 'rsi',\n    });\n\n    // Convert to LineData format\n    const lineData: LineData[] = rsiValues.map(value => ({\n      time: value.time as any,\n      value: value.value\n    }));\n\n    rsiSeries.setData(lineData);\n\n    // Add horizontal lines for overbought/oversold levels\n    const overboughtSeries = chartInstance.addSeries(LineSeries, {\n      color: '#FF4444',\n      lineWidth: 1,\n      lineStyle: 2, // dashed\n      priceScaleId: 'rsi',\n    });\n\n    const oversoldSeries = chartInstance.addSeries(LineSeries, {\n      color: '#44FF44',\n      lineWidth: 1,\n      lineStyle: 2, // dashed\n      priceScaleId: 'rsi',\n    });\n\n    // Create horizontal line data\n    if (rsiValues.length > 0) {\n      const startTime = rsiValues[0].time;\n      const endTime = rsiValues[rsiValues.length - 1].time;\n      \n      overboughtSeries.setData([\n        { time: startTime as any, value: config.overbought },\n        { time: endTime as any, value: config.overbought }\n      ]);\n\n      oversoldSeries.setData([\n        { time: startTime as any, value: config.oversold },\n        { time: endTime as any, value: config.oversold }\n      ]);\n    }\n\n    const indicator: IndicatorSeries = {\n      id: `rsi-${Date.now()}`,\n      type: 'RSI',\n      name: `RSI(${config.period})`,\n      series: [rsiSeries, overboughtSeries, oversoldSeries],\n      visible: true,\n      config\n    };\n\n    setIndicators(prev => [...prev, indicator]);\n    return indicator.id;\n  }, [chartInstance, convertToIndicatorData]);\n\n  // Add Moving Average indicator\n  const addMovingAverage = useCallback((data: any[], config: MovingAverageConfig = DEFAULT_MA_CONFIG) => {\n    if (!chartInstance) return null;\n\n    const indicatorData = convertToIndicatorData(data);\n    const maValues = calculateMovingAverage(indicatorData, config);\n    \n    const maSeries = chartInstance.addSeries(LineSeries, {\n      color: config.type === 'SMA' ? '#2962FF' : '#FF9800',\n      lineWidth: 2,\n      title: `${config.type}(${config.period})`,\n    });\n\n    const lineData: LineData[] = maValues.map(value => ({\n      time: value.time as any,\n      value: value.value\n    }));\n\n    maSeries.setData(lineData);\n\n    const indicator: IndicatorSeries = {\n      id: `ma-${Date.now()}`,\n      type: 'MA',\n      name: `${config.type}(${config.period})`,\n      series: [maSeries],\n      visible: true,\n      config\n    };\n\n    setIndicators(prev => [...prev, indicator]);\n    return indicator.id;\n  }, [chartInstance, convertToIndicatorData]);\n\n  // Add MACD indicator\n  const addMACD = useCallback((data: any[], config: MACDConfig = DEFAULT_MACD_CONFIG) => {\n    if (!chartInstance) return null;\n\n    const indicatorData = convertToIndicatorData(data);\n    const macdValues = calculateMACD(indicatorData, config);\n    \n    const macdSeries = chartInstance.addSeries(LineSeries, {\n      color: '#2196F3',\n      lineWidth: 2,\n      title: `MACD(${config.fastPeriod},${config.slowPeriod},${config.signalPeriod})`,\n      priceScaleId: 'macd',\n    });\n\n    const signalSeries = chartInstance.addSeries(LineSeries, {\n      color: '#FF5722',\n      lineWidth: 2,\n      title: 'Signal',\n      priceScaleId: 'macd',\n    });\n\n    const macdLineData: LineData[] = macdValues.map(value => ({\n      time: value.time as any,\n      value: value.macd\n    }));\n\n    const signalLineData: LineData[] = macdValues.map(value => ({\n      time: value.time as any,\n      value: value.signal\n    }));\n\n    macdSeries.setData(macdLineData);\n    signalSeries.setData(signalLineData);\n\n    const indicator: IndicatorSeries = {\n      id: `macd-${Date.now()}`,\n      type: 'MACD',\n      name: `MACD(${config.fastPeriod},${config.slowPeriod},${config.signalPeriod})`,\n      series: [macdSeries, signalSeries],\n      visible: true,\n      config\n    };\n\n    setIndicators(prev => [...prev, indicator]);\n    return indicator.id;\n  }, [chartInstance, convertToIndicatorData]);\n\n  // Add Bollinger Bands indicator\n  const addBollingerBands = useCallback((data: any[], config: BollingerBandsConfig = DEFAULT_BOLLINGER_BANDS_CONFIG) => {\n    if (!chartInstance) return null;\n\n    const indicatorData = convertToIndicatorData(data);\n    const bbValues = calculateBollingerBands(indicatorData, config);\n    \n    const upperSeries = chartInstance.addSeries(LineSeries, {\n      color: '#9C27B0',\n      lineWidth: 1,\n      title: `BB Upper(${config.period})`,\n    });\n\n    const middleSeries = chartInstance.addSeries(LineSeries, {\n      color: '#673AB7',\n      lineWidth: 2,\n      title: `BB Middle(${config.period})`,\n    });\n\n    const lowerSeries = chartInstance.addSeries(LineSeries, {\n      color: '#9C27B0',\n      lineWidth: 1,\n      title: `BB Lower(${config.period})`,\n    });\n\n    const upperData: LineData[] = bbValues.map(value => ({\n      time: value.time as any,\n      value: value.upper\n    }));\n\n    const middleData: LineData[] = bbValues.map(value => ({\n      time: value.time as any,\n      value: value.middle\n    }));\n\n    const lowerData: LineData[] = bbValues.map(value => ({\n      time: value.time as any,\n      value: value.lower\n    }));\n\n    upperSeries.setData(upperData);\n    middleSeries.setData(middleData);\n    lowerSeries.setData(lowerData);\n\n    const indicator: IndicatorSeries = {\n      id: `bb-${Date.now()}`,\n      type: 'BB',\n      name: `BB(${config.period})`,\n      series: [upperSeries, middleSeries, lowerSeries],\n      visible: true,\n      config\n    };\n\n    setIndicators(prev => [...prev, indicator]);\n    return indicator.id;\n  }, [chartInstance, convertToIndicatorData]);\n\n  // Remove indicator\n  const removeIndicator = useCallback((indicatorId: string) => {\n    if (!chartInstance) return;\n\n    const indicator = indicators.find(ind => ind.id === indicatorId);\n    if (indicator) {\n      indicator.series.forEach(series => {\n        chartInstance.removeSeries(series);\n      });\n\n      setIndicators(prev => prev.filter(ind => ind.id !== indicatorId));\n    }\n  }, [chartInstance, indicators]);\n\n  // Toggle indicator visibility\n  const toggleIndicator = useCallback((indicatorId: string) => {\n    setIndicators(prev => prev.map(indicator => {\n      if (indicator.id === indicatorId) {\n        const newVisibility = !indicator.visible;\n        indicator.series.forEach(series => {\n          series.applyOptions({\n            visible: newVisibility\n          });\n        });\n        return { ...indicator, visible: newVisibility };\n      }\n      return indicator;\n    }));\n  }, []);\n\n  // Clear all indicators\n  const clearAllIndicators = useCallback(() => {\n    if (!chartInstance) return;\n\n    indicators.forEach(indicator => {\n      indicator.series.forEach(series => {\n        chartInstance.removeSeries(series);\n      });\n    });\n\n    setIndicators([]);\n  }, [chartInstance, indicators]);\n\n  return {\n    indicators,\n    addRSI,\n    addMovingAverage,\n    addMACD,\n    addBollingerBands,\n    removeIndicator,\n    toggleIndicator,\n    clearAllIndicators\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useDebounced.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useLightweightChart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/usePortfolio.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MiCAComplianceStatus' is defined but never used.","line":4,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":73},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'findMarketPrice'. Either include it or remove the dependency array.","line":191,"column":6,"nodeType":"ArrayExpression","endLine":191,"endColumn":66,"suggestions":[{"desc":"Update the dependencies array to be: [accountData.balances, findMarketPrice, getMiCAComplianceStatus]","fix":{"range":[7372,7432],"text":"[accountData.balances, findMarketPrice, getMiCAComplianceStatus]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { getAccount } from '../services/restClient';\nimport type { AccountResponse, Balance } from '../services/restClient';\nimport type { PortfolioBalance, MiCAComplianceInfo, MiCAComplianceStatus } from '../types/portfolio';\nimport { useAssets } from './useAssets';\nimport { useThrottledState } from './useThrottledState';\n\nexport interface UsePortfolioReturn {\n  balances: PortfolioBalance[];\n  loading: boolean;\n  error: string | null;\n  accountData: AccountResponse | null;\n  refetch: () => Promise<void>;\n  totalValue: number;\n  totalChange24h: number;\n  isConnected: boolean;\n  lastSyncTime: number | null;\n}\n\n/**\n * Hook do zarządzania danymi portfolio użytkownika\n * Łączy dane z AccountPanel z cenami z MarketPanel\n */\nexport const usePortfolio = (): UsePortfolioReturn => {\n  const [accountData, setAccountData] = useState<AccountResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [lastSyncTime, setLastSyncTime] = useState<number | null>(null);\n  \n  // Use the existing assets hook for market data\n  const { assets: marketData, isConnected } = useAssets();\n\n  // MiCA compliance mapping for EU regulations\n  const getMiCAComplianceStatus = useCallback((asset: string): MiCAComplianceInfo => {\n    // MiCA-compliant stablecoins (remain available in EU)\n    const MICA_COMPLIANT = new Set(['USDC']);\n    \n    // Non-compliant stablecoins (delisted from EU by March 31, 2025)\n    const EU_DELISTING = new Set(['USDT', 'FDUSD', 'TUSD', 'USDP', 'DAI', 'AEUR', 'XUSD', 'PAXG']);\n\n    if (MICA_COMPLIANT.has(asset)) {\n      return {\n        status: 'COMPLIANT',\n        recommendation: 'MiCA-compliant, pozostanie dostępny w EU'\n      };\n    }\n\n    if (EU_DELISTING.has(asset)) {\n      return {\n        status: 'DELISTING',\n        delistingDate: '31 marca 2025',\n        recommendation: 'Zostanie usunięty z Binance EU. Rozważ konwersję do USDC'\n      };\n    }\n\n    return {\n      status: 'UNKNOWN',\n      recommendation: 'Status MiCA nieznany'\n    };\n  }, []);\n\n  const fetchAccountData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const data = await getAccount();\n      setAccountData(data);\n      setLastSyncTime(Date.now());\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Błąd podczas pobierania danych portfolio');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchAccountData();\n  }, [fetchAccountData]);\n\n  // Fiat currencies that need special handling (inverted USD pairs)\n  const FIAT_CURRENCIES = useMemo(() => new Set([\n    'EUR', 'GBP', 'PLN', 'JPY', 'CNY', 'TRY', 'BRL', 'ARS', 'MXN', 'ZAR', 'UAH', 'RON',\n    'KZT', 'NGN', 'CZK', 'CHF', 'SEK', 'NOK', 'DKK', 'HUF', 'AUD', 'NZD', 'CAD',\n    'HKD', 'SGD', 'COP', 'CLP', 'PEN', 'PHP', 'IDR', 'INR', 'THB', 'VND', 'ILS',\n    'AED', 'SAR', 'QAR', 'KRW', 'MYR'\n  ]), []);\n\n  // Helper function to find market data for any asset\n  const findMarketPrice = useCallback((asset: string) => {\n    // USDC is our new base currency (MiCA-compliant)\n    if (asset === 'USDC') {\n      return { price: 1, priceChangePercent: 0 };\n    }\n\n    // Major stablecoins - assume ~$1.00 for portfolio tracking\n    // (exact spreads are not critical for portfolio valuation)\n    const MAJOR_STABLECOINS = new Set(['USDT', 'DAI', 'TUSD', 'USDP', 'FDUSD']);\n    if (MAJOR_STABLECOINS.has(asset)) {\n      return { price: 1, priceChangePercent: 0 };\n    }\n\n    // First try standard format: {ASSET}USDC\n    let marketAsset = marketData.find(m => m.symbol === `${asset}USDC`);\n    if (marketAsset) {\n      return { price: marketAsset.price, priceChangePercent: marketAsset.priceChangePercent };\n    }\n\n    // For fiat currencies, try different USDC-based formats (MiCA-compliant)\n    if (FIAT_CURRENCIES.has(asset)) {\n      // Try USDC{FIAT} format (e.g., USDCPLN, USDCTRY)\n      marketAsset = marketData.find(m => m.symbol === `USDC${asset}`);\n      if (marketAsset && marketAsset.price > 0) {\n        // Invert the price: if USDCPLN = 4.0, then PLN price = 1/4.0 = 0.25 USD\n        const invertedPrice = 1 / marketAsset.price;\n        // For inverted pairs, we also need to invert the percentage change\n        const invertedPriceChange = marketAsset.priceChangePercent ? -marketAsset.priceChangePercent : 0;\n        return { price: invertedPrice, priceChangePercent: invertedPriceChange };\n      }\n\n      // Try {FIAT}USDC format (e.g., EURUSDC)\n      marketAsset = marketData.find(m => m.symbol === `${asset}USDC`);\n      if (marketAsset) {\n        // Direct price: EURUSDC = 1.16 means 1 EUR = 1.16 USD\n        return { price: marketAsset.price, priceChangePercent: marketAsset.priceChangePercent };\n      }\n\n      // Fallback for fiat: Try USDT{FIAT} format (e.g., USDTZAR, USDTUAH)\n      marketAsset = marketData.find(m => m.symbol === `USDT${asset}`);\n      if (marketAsset && marketAsset.price > 0) {\n        // Invert the price: if USDTZAR = 18.0, then ZAR price = 1/18.0 = 0.056 USD\n        const invertedPrice = 1 / marketAsset.price;\n        // For inverted pairs, we also need to invert the percentage change\n        const invertedPriceChange = marketAsset.priceChangePercent ? -marketAsset.priceChangePercent : 0;\n        return { price: invertedPrice, priceChangePercent: invertedPriceChange };\n      }\n\n      // Fallback for fiat: Try {FIAT}USDT format (e.g., EURUSDT)\n      marketAsset = marketData.find(m => m.symbol === `${asset}USDT`);\n      if (marketAsset) {\n        // Direct price: EURUSDT = 1.16 means 1 EUR = 1.16 USD\n        return { price: marketAsset.price, priceChangePercent: marketAsset.priceChangePercent };\n      }\n    }\n\n    // Fallback: Try {ASSET}USDT for assets that don't have USDC pairs yet\n    // Note: This will be phased out as USDT pairs are delisted in EU\n    marketAsset = marketData.find(m => m.symbol === `${asset}USDT`);\n    if (marketAsset) {\n      return { price: marketAsset.price, priceChangePercent: marketAsset.priceChangePercent };\n    }\n\n    return { price: undefined, priceChangePercent: undefined };\n  }, [marketData, FIAT_CURRENCIES]);\n\n  // Transform account balances to portfolio format with market data\n  const balances: PortfolioBalance[] = useMemo(() => {\n    if (!accountData?.balances || !Array.isArray(accountData.balances)) {\n      return [];\n    }\n    \n    return accountData.balances.map((balance: Balance) => {\n      const asset = balance.asset;\n      const free = parseFloat(balance.free);\n      const locked = parseFloat(balance.locked);\n      const total = free + locked;\n      \n      // Find market data for this asset (handles both crypto and fiat)\n      const marketPrice = findMarketPrice(asset);\n      const currentPrice = marketPrice.price;\n      const priceChange24h = marketPrice.priceChangePercent;\n      \n      // Calculate USD values\n      const valueUSD = currentPrice ? total * currentPrice : 0;\n      const valueChange24h = currentPrice && priceChange24h \n        ? valueUSD * (priceChange24h / 100) \n        : 0;\n      \n      return {\n        asset,\n        free,\n        locked,\n        total,\n        currentPrice,\n        priceChange24h,\n        valueUSD,\n        valueChange24h,\n        micaCompliance: getMiCAComplianceStatus(asset),\n      };\n    });\n  }, [accountData?.balances, marketData, getMiCAComplianceStatus]);\n\n  // Calculate portfolio metrics with throttling\n  const totalValue = useMemo(() => {\n    return balances.reduce((total, balance) => total + (balance.valueUSD || 0), 0);\n  }, [balances]);\n\n  // Use throttled state for total value to prevent excessive UI updates\n  const [throttledTotalValue, setThrottledTotalValue] = useThrottledState(totalValue, 500);\n\n  // Update throttled value when totalValue changes\n  useEffect(() => {\n    setThrottledTotalValue(totalValue);\n  }, [totalValue, setThrottledTotalValue]);\n\n  const totalChange24h = useMemo(() => {\n    const totalCurrent = totalValue;\n    const totalPrevious = balances.reduce((total, balance) => {\n      const previousValue = (balance.valueUSD || 0) - (balance.valueChange24h || 0);\n      return total + previousValue;\n    }, 0);\n    \n    if (totalPrevious === 0) return 0;\n    return ((totalCurrent - totalPrevious) / totalPrevious) * 100;\n  }, [balances, totalValue]);\n\n  return {\n    balances,\n    loading,\n    error,\n    accountData,\n    refetch: fetchAccountData,\n    totalValue: throttledTotalValue,\n    totalChange24h,\n    isConnected,\n    lastSyncTime,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/usePriceChangeAnimation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[278,281],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[278,281],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect } from 'react';\n\n/**\n * Hook do wykrywania zmian w cenie aktywów dla animacji\n * @param assets - lista aktywów do monitorowania\n * @returns Map z symbolami i kierunkiem zmiany ('up' | 'down' | null)\n */\nexport const usePriceChangeAnimation = (assets: any[]) => {\n  const previousPricesRef = useRef<Map<string, number>>(new Map());\n  const changesRef = useRef<Map<string, 'up' | 'down' | null>>(new Map());\n\n  useEffect(() => {\n    const currentPrices = new Map<string, number>();\n    const newChanges = new Map<string, 'up' | 'down' | null>();\n\n    assets.forEach(asset => {\n      const currentPrice = asset.price;\n      const previousPrice = previousPricesRef.current.get(asset.symbol);\n      \n      currentPrices.set(asset.symbol, currentPrice);\n\n      if (previousPrice !== undefined && previousPrice !== currentPrice) {\n        if (currentPrice > previousPrice) {\n          newChanges.set(asset.symbol, 'up');\n        } else if (currentPrice < previousPrice) {\n          newChanges.set(asset.symbol, 'down');\n        }\n      }\n    });\n\n    // Update refs\n    previousPricesRef.current = currentPrices;\n    changesRef.current = newChanges;\n\n    // Clear animations after 2 seconds\n    if (newChanges.size > 0) {\n      setTimeout(() => {\n        changesRef.current.clear();\n      }, 2000);\n    }\n  }, [assets]);\n\n  return changesRef.current;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useThrottledCallback.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":7,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[236,239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[236,239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useCallback } from 'react';\n\n/**\n * Custom hook for throttling state updates in high-frequency scenarios\n * Uses requestAnimationFrame for smooth performance\n */\nexport function useThrottledCallback<T extends (...args: any[]) => void>(\n  callback: T,\n  delay: number = 16 // ~60fps\n): T {\n  const timeoutRef = useRef<number | null>(null);\n  const lastCallRef = useRef<number>(0);\n\n  const throttledCallback = useCallback((...args: Parameters<T>) => {\n    const now = performance.now();\n    \n    if (now - lastCallRef.current >= delay) {\n      // Call immediately if enough time has passed\n      lastCallRef.current = now;\n      callback(...args);\n    } else {\n      // Schedule for later if called too frequently\n      if (timeoutRef.current) {\n        cancelAnimationFrame(timeoutRef.current);\n      }\n      \n      timeoutRef.current = requestAnimationFrame(() => {\n        lastCallRef.current = performance.now();\n        callback(...args);\n        timeoutRef.current = null;\n      });\n    }\n  }, [callback, delay]) as T;\n\n  return throttledCallback;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/hooks/useThrottledState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/bollingerBands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/macd.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/movingAverage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/rsi.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'gains' is never reassigned. Use 'const' instead.","line":17,"column":7,"nodeType":"Identifier","messageId":"useConst","endLine":17,"endColumn":22,"fix":{"range":[426,451],"text":"const gains: number[] = [];"}},{"ruleId":"prefer-const","severity":2,"message":"'losses' is never reassigned. Use 'const' instead.","line":18,"column":7,"nodeType":"Identifier","messageId":"useConst","endLine":18,"endColumn":23,"fix":{"range":[454,480],"text":"const losses: number[] = [];"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import type { CandleData, RSIValue, RSIConfig } from './types';\n\n/**\n * Calculate RSI (Relative Strength Index)\n * @param data Array of candle data\n * @param config RSI configuration\n * @returns Array of RSI values\n */\nexport function calculateRSI(data: CandleData[], config: RSIConfig): RSIValue[] {\n  const { period } = config;\n  const result: RSIValue[] = [];\n  \n  if (data.length < period + 1) {\n    return result;\n  }\n\n  let gains: number[] = [];\n  let losses: number[] = [];\n\n  // Calculate initial gains and losses\n  for (let i = 1; i <= period; i++) {\n    const change = data[i].close - data[i - 1].close;\n    gains.push(change > 0 ? change : 0);\n    losses.push(change < 0 ? Math.abs(change) : 0);\n  }\n\n  let avgGain = gains.reduce((sum, gain) => sum + gain, 0) / period;\n  let avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / period;\n\n  // Calculate RSI for the first period\n  let rs = avgGain / (avgLoss || 1);\n  let rsi = 100 - (100 / (1 + rs));\n  \n  result.push({\n    time: data[period].time,\n    value: rsi\n  });\n\n  // Calculate subsequent RSI values using smoothed averages\n  for (let i = period + 1; i < data.length; i++) {\n    const change = data[i].close - data[i - 1].close;\n    const gain = change > 0 ? change : 0;\n    const loss = change < 0 ? Math.abs(change) : 0;\n\n    avgGain = ((avgGain * (period - 1)) + gain) / period;\n    avgLoss = ((avgLoss * (period - 1)) + loss) / period;\n\n    rs = avgGain / (avgLoss || 1);\n    rsi = 100 - (100 / (1 + rs));\n\n    result.push({\n      time: data[i].time,\n      value: rsi\n    });\n  }\n\n  return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/indicators/types.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":16,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":16,"endColumn":26,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[243,287],"text":"type RSIValue = IndicatorValue"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":32,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":32,"endColumn":36,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[509,563],"text":"type MovingAverageValue = IndicatorValue"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Types for technical indicators\nexport interface CandleData {\n  time: number;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume?: number;\n}\n\nexport interface IndicatorValue {\n  time: number;\n  value: number;\n}\n\nexport interface RSIValue extends IndicatorValue {}\n\nexport interface MACDValue {\n  time: number;\n  macd: number;\n  signal: number;\n  histogram: number;\n}\n\nexport interface BollingerBandsValue {\n  time: number;\n  upper: number;\n  middle: number;\n  lower: number;\n}\n\nexport interface MovingAverageValue extends IndicatorValue {}\n\n// Indicator configuration interfaces\nexport interface RSIConfig {\n  period: number;\n  overbought: number;\n  oversold: number;\n}\n\nexport interface MACDConfig {\n  fastPeriod: number;\n  slowPeriod: number;\n  signalPeriod: number;\n}\n\nexport interface BollingerBandsConfig {\n  period: number;\n  multiplier: number;\n}\n\nexport interface MovingAverageConfig {\n  period: number;\n  type: 'SMA' | 'EMA';\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/BinanceTickerWSClient.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":51,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":51,"endColumn":16,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1920,1933],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1999,2002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1999,2002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Optimized Binance WebSocket Client for Selected Tickers\n// Provides real-time 24hr ticker statistics for specific symbols only\n// Fixes performance issue: was downloading 570MB for all symbols, now only selected ones\n\nexport interface BinanceTicker24hr {\n  e: string;      // Event type (always \"24hrTicker\")\n  E: number;      // Event time (timestamp in milliseconds)\n  s: string;      // Symbol (e.g., \"BTCUSDT\")\n  p: string;      // Price change\n  P: string;      // Price change percent\n  w: string;      // Weighted average price\n  x: string;      // First trade(F)-1 price\n  c: string;      // Last price\n  Q: string;      // Last quantity\n  b: string;      // Best bid price\n  B: string;      // Best bid quantity\n  a: string;      // Best ask price\n  A: string;      // Best ask quantity\n  o: string;      // Open price\n  h: string;      // High price\n  l: string;      // Low price\n  v: string;      // Total traded base asset volume\n  q: string;      // Total traded quote asset volume\n  O: number;      // Statistics open time\n  C: number;      // Statistics close time\n  F: number;      // First trade ID\n  L: number;      // Last trade Id\n  n: number;      // Total number of trades\n}\n\nexport type BinanceTickerListener = (tickers: BinanceTicker24hr[]) => void;\n\nimport { createLogger } from './logger';\n\nexport class BinanceTickerWSClient {\n  private ws: WebSocket | null = null;\n  private listeners: BinanceTickerListener[] = [];\n  private shouldReconnect = true;\n  private reconnectTimeout: number | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private isDestroyed = false;\n  private readonly baseUrl: string;\n  private subscribedSymbols = new Set<string>();\n\n  private logger = createLogger('binance:ticker');\n\n  constructor() {\n    // Use environment variable for Binance WebSocket URL, with fallback\n  // Prefer env var in tests; Vite will inline in builds\n  // @ts-ignore\n  const fromEnv = (typeof process !== 'undefined' && (process as any).env?.VITE_BINANCE_WS_URL) as string | undefined;\n  this.baseUrl = fromEnv || 'wss://data-stream.binance.vision/ws';\n  this.logger.debug('init', { baseUrl: this.baseUrl });\n    // Don't auto-connect, wait for subscriptions\n  }\n\n  // debug flag handled by central logger now\n\n  // Subscribe to specific symbols for ticker updates\n  subscribe(symbols: string[]) {\n    symbols.forEach(symbol => {\n      const symbolLower = symbol.toLowerCase();\n      if (!this.subscribedSymbols.has(symbolLower)) {\n        this.subscribedSymbols.add(symbolLower);\n  this.logger.trace('subscribe', { symbol });\n      }\n    });\n    \n    if (this.subscribedSymbols.size > 0 && !this.ws) {\n      this.connect();\n    }\n  }\n\n  // Unsubscribe from specific symbols\n  unsubscribe(symbols: string[]) {\n    symbols.forEach(symbol => {\n      const symbolLower = symbol.toLowerCase();\n      this.subscribedSymbols.delete(symbolLower);\n  this.logger.trace('unsubscribe', { symbol });\n    });\n    \n    if (this.subscribedSymbols.size === 0 && this.ws) {\n  this.logger.debug('no-subscriptions-close');\n      this.ws.close();\n    }\n  }\n\n  private buildStreamUrl(): string {\n    if (this.subscribedSymbols.size === 0) {\n      throw new Error('No symbols subscribed');\n    }\n    \n    // Build streams for subscribed symbols: symbol@ticker\n    const streams = Array.from(this.subscribedSymbols).map(symbol => `${symbol}@ticker`);\n    const streamParam = streams.join('/');\n\n    // Support both single-stream (/ws/<stream>) and combined streams (/stream?streams=...)\n    // If only one stream and baseUrl ends with /ws, use single stream path for efficiency\n    if (streams.length === 1 && this.baseUrl.endsWith('/ws')) {\n      return `${this.baseUrl}/${streams[0]}`;\n    }\n\n    // Otherwise use combined stream format regardless of trailing segment in baseUrl\n    // Normalize to data-stream root, preserving potential custom host in baseUrl\n    const root = this.baseUrl.replace(/\\/ws$/i, '').replace(/\\/stream\\??streams=?$/i, '');\n    return `${root}/stream?streams=${encodeURIComponent(streamParam)}`;\n  }\n\n  private connect() {\n    if (this.isDestroyed) {\n  this.logger.debug('skip-connect-destroyed');\n      return;\n    }\n\n    if (this.subscribedSymbols.size === 0) {\n  this.logger.trace('skip-connect-empty');\n      return;\n    }\n\n  const url = this.buildStreamUrl();\n    this.logger.debug('connecting', { url });\n\n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.onopen = () => {\n  this.logger.info('connected', { streams: this.subscribedSymbols.size });\n        this.reconnectAttempts = 0;\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          \n          // Handle single ticker update (not array like before)\n          if (data.e === '24hrTicker') {\n            if (data.s && this.subscribedSymbols.has(String(data.s).toLowerCase())) {\n              this.notifyListeners([data]); // Wrap in array for compatibility\n            }\n          } else if (Array.isArray(data)) {\n            // Some endpoints may send arrays (safety)\n            const filtered = (data as BinanceTicker24hr[]).filter(t => t.s && this.subscribedSymbols.has(String(t.s).toLowerCase()));\n            if (filtered.length) this.notifyListeners(filtered);\n          } else if (data && data.stream && data.data) {\n            // Combined stream payload: { stream: 'btcusdt@ticker', data: {...} }\n            const payload = data.data as BinanceTicker24hr;\n            if (payload.e === '24hrTicker' && payload.s && this.subscribedSymbols.has(String(payload.s).toLowerCase())) {\n              this.notifyListeners([payload]);\n            }\n          }\n        } catch (error) {\n          this.logger.warn('parse-failed', error);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n  this.logger.error('ws-error', error);\n  this.logger.debug('ws-error-meta', { url, state: this.ws?.readyState });\n      };\n\n      this.ws.onclose = (event) => {\n  this.logger.warn('closed', { code: event.code, reason: event.reason });\n        this.ws = null;\n        \n        // Don't attempt reconnection if the close was due to an invalid endpoint\n        if (event.code === 1006) {\n          this.logger.error('invalid-endpoint?');\n          this.shouldReconnect = false;\n          return;\n        }\n        \n        if (this.shouldReconnect && !this.isDestroyed && this.reconnectAttempts < this.maxReconnectAttempts && this.subscribedSymbols.size > 0) {\n          const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n          this.logger.debug('reconnect-schedule', { delay, attempt: this.reconnectAttempts + 1 });\n          \n          this.reconnectTimeout = window.setTimeout(() => {\n            this.reconnectAttempts++;\n            this.connect();\n          }, delay);\n        } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n          this.logger.error('reconnect-max');\n        }\n      };\n\n    } catch (error) {\n      console.error('[BinanceTickerWSClient] Failed to create WebSocket:', error);\n    }\n  }\n\n  // Replace current subscriptions with a new set and reconnect\n  setSubscriptions(symbols: string[]) {\n    const next = new Set(symbols.map(s => s.toLowerCase()));\n    // If identical, do nothing\n    if (\n      next.size === this.subscribedSymbols.size &&\n      Array.from(next).every(s => this.subscribedSymbols.has(s))\n    ) {\n      return;\n    }\n\n  this.logger.debug('set-subscriptions', { count: next.size });\n    this.subscribedSymbols = next;\n\n    // Reconnect with new streams\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.reconnectAttempts = 0;\n    this.connect();\n  }\n\n  private notifyListeners(tickers: BinanceTicker24hr[]) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(tickers);\n      } catch (error) {\n  this.logger.error('listener-error', error);\n      }\n    });\n  }\n\n  addListener(listener: BinanceTickerListener) {\n    this.listeners.push(listener);\n  this.logger.trace('add-listener', { total: this.listeners.length });\n  }\n\n  removeListener(listener: BinanceTickerListener) {\n    const index = this.listeners.indexOf(listener);\n    if (index !== -1) {\n      this.listeners.splice(index, 1);\n  this.logger.trace('remove-listener', { total: this.listeners.length });\n    }\n  }\n\n  destroy() {\n  this.logger.info('destroy');\n    this.isDestroyed = true;\n    this.shouldReconnect = false;\n    \n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    this.listeners = [];\n  }\n\n  // Get current connection state\n  get isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n}\n\nexport default BinanceTickerWSClient;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/binanceAPI.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2819,2822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2819,2822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4837,4840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4837,4840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5539,5542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5539,5542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":165,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5568,5571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5568,5571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6170,6173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6170,6173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6225,6228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6225,6228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6241,6244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6241,6244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7877,7880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7877,7880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Direct Binance REST API client for historical data\n// This bypasses the backend and connects directly to Binance public API\n\nimport axios from 'axios';\nimport { createLogger } from './logger';\nimport type { Asset } from '../types/asset';\n\n// Binance API base URL (public, no authentication required for market data)\nconst BINANCE_API_BASE = 'https://api.binance.com/api/v3';\n\nexport interface BinanceKlineData {\n  openTime: number;        // Open time (timestamp in milliseconds)\n  open: string;           // Open price\n  high: string;           // High price\n  low: string;            // Low price\n  close: string;          // Close price\n  volume: string;         // Volume\n  closeTime: number;      // Close time (timestamp in milliseconds)\n  quoteAssetVolume: string;\n  numberOfTrades: number;\n  takerBuyBaseAssetVolume: string;\n  takerBuyQuoteAssetVolume: string;\n}\n\n// Raw response from Binance API (array format)\nexport type BinanceKlineRaw = [\n  number,  // Open time\n  string,  // Open price\n  string,  // High price\n  string,  // Low price\n  string,  // Close price\n  string,  // Volume\n  number,  // Close time\n  string,  // Quote asset volume\n  number,  // Number of trades\n  string,  // Taker buy base asset volume\n  string   // Taker buy quote asset volume\n];\n\n// Lightweight-charts compatible format\nexport interface LightweightChartsKline {\n  time: number;  // Unix timestamp in seconds (as Time type for lightweight-charts)\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n}\n\n/**\n * Fetch historical klines directly from Binance API\n * @param symbol Trading pair symbol (e.g., 'BTCUSDT')\n * @param interval Kline interval (e.g., '1m', '5m', '1h', '1d')\n * @param limit Number of klines to retrieve (max 1000, default 100)\n * @returns Promise with klines data\n */\nexport async function fetchBinanceKlines(\n  symbol: string, \n  interval: string = '1m', \n  limit: number = 100\n): Promise<BinanceKlineData[]> {\n  const logger = createLogger('binance:api');\n  try {\n    logger.debug('fetch-klines', { symbol, interval, limit });\n    \n    const response = await axios.get<BinanceKlineRaw[]>(`${BINANCE_API_BASE}/klines`, {\n      params: {\n        symbol: symbol.toUpperCase(),\n        interval,\n        limit: Math.min(limit, 1000) // Binance API limit\n      },\n      timeout: 10000\n    });\n\n    const klines: BinanceKlineData[] = response.data.map(raw => ({\n      openTime: raw[0],\n      open: raw[1],\n      high: raw[2],\n      low: raw[3],\n      close: raw[4],\n      volume: raw[5],\n      closeTime: raw[6],\n      quoteAssetVolume: raw[7],\n      numberOfTrades: raw[8],\n      takerBuyBaseAssetVolume: raw[9],\n      takerBuyQuoteAssetVolume: raw[10]\n    }));\n\n  logger.trace('klines-fetched', klines.length);\n    return klines;\n\n  } catch (error) {\n  logger.error('klines-error', error as any);\n    throw new Error(`Failed to fetch klines for ${symbol}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Convert Binance klines to lightweight-charts format\n * @param klines Array of Binance kline data\n * @returns Array in lightweight-charts candlestick format\n */\nexport function convertToLightweightChartsFormat(klines: BinanceKlineData[]): LightweightChartsKline[] {\n  return klines.map(kline => ({\n    time: Math.floor(kline.openTime / 1000), // Convert milliseconds to seconds\n    open: parseFloat(kline.open),\n    high: parseFloat(kline.high),\n    low: parseFloat(kline.low),\n    close: parseFloat(kline.close)\n  }));\n}\n\n/**\n * Fetch klines and convert to lightweight-charts format in one step\n * @param symbol Trading pair symbol\n * @param interval Kline interval\n * @param limit Number of klines\n * @returns Promise with lightweight-charts compatible data\n */\nexport async function fetchLightweightChartsKlines(\n  symbol: string,\n  interval: string = '1m',\n  limit: number = 100\n): Promise<LightweightChartsKline[]> {\n  const klines = await fetchBinanceKlines(symbol, interval, limit);\n  return convertToLightweightChartsFormat(klines);\n}\n\nexport default {\n  fetchBinanceKlines,\n  convertToLightweightChartsFormat,\n  fetchLightweightChartsKlines,\n  fetchAllTradingPairs\n};\n\n/**\n * Fetch all trading pairs from local backend API with 24hr statistics\n * This reduces direct calls to Binance API and uses cached data\n * @returns Promise with array of Asset objects\n */\nexport async function fetchAllTradingPairs(): Promise<Asset[]> {\n  const logger = createLogger('binance:api');\n  try {\n    logger.debug('fetch-trading-pairs');\n    \n    const [exchangeInfo, ticker24hr] = await Promise.all([\n      axios.get('/api/exchangeInfo', { timeout: 10000 }),\n      axios.get('/api/24hr', { timeout: 10000 })\n    ]);\n\n    // Dozwolone rynki (quote) — priorytet dla USDC (MiCA-compliant), backup USDT\n    const MARKET_QUOTES: string[] = (((typeof process !== 'undefined' && (process as any).env?.VITE_MARKET_QUOTES) || 'USDC,USDT,BTC,ETH,BNB'))\n      .split(',')\n      .map((q: string) => q.trim().toUpperCase())\n      .filter(Boolean);\n\n    // Lista walut fiat dla par USDC{FIAT} i USDT{FIAT}\n    const FIAT_CURRENCIES = new Set([\n      'EUR', 'GBP', 'PLN', 'JPY', 'CNY', 'TRY', 'BRL', 'ARS', 'MXN', 'ZAR', 'UAH', 'RON',\n      'KZT', 'NGN', 'CZK', 'CHF', 'SEK', 'NOK', 'DKK', 'HUF', 'AUD', 'NZD', 'CAD',\n      'HKD', 'SGD', 'COP', 'CLP', 'PEN', 'PHP', 'IDR', 'INR', 'THB', 'VND', 'ILS',\n      'AED', 'SAR', 'QAR', 'KRW', 'MYR'\n    ]);\n\n    // Filtruj aktywne pary: standardowe (quote w MARKET_QUOTES) + pary fiat (USDC{FIAT} i USDT{FIAT})\n    const filteredPairs = (exchangeInfo.data as any).symbols.filter((symbol: any) => \n      symbol.status === 'TRADING' &&\n      symbol.isSpotTradingAllowed &&\n      (\n        // Standardowe pary: quote asset w dozwolonych rynkach\n        MARKET_QUOTES.includes(symbol.quoteAsset) ||\n        // Pary fiat: USDC{FIAT} (MiCA-compliant, preferowane)\n        (symbol.baseAsset === 'USDC' && FIAT_CURRENCIES.has(symbol.quoteAsset)) ||\n        // Pary fiat: USDT{FIAT} (backup, będą usunięte w EU)\n        (symbol.baseAsset === 'USDT' && FIAT_CURRENCIES.has(symbol.quoteAsset))\n      )\n    );\n\n    // Mapowanie danych na format Asset\n  const assets: Asset[] = filteredPairs.map((pair: any) => {\n      const tickerData = (ticker24hr.data as any[]).find((t: any) => t.symbol === pair.symbol);\n      \n      if (!tickerData) {\n        // Fallback gdy brak ticker data\n        return {\n          symbol: pair.symbol,\n          baseAsset: pair.baseAsset,\n          quoteAsset: pair.quoteAsset,\n          price: 0,\n          priceChange: 0,\n          priceChangePercent: 0,\n          volume: 0,\n          count: 0,\n          status: pair.status,\n        };\n      }\n\n      return {\n        symbol: pair.symbol,\n        baseAsset: pair.baseAsset,\n        quoteAsset: pair.quoteAsset,\n        price: parseFloat(tickerData.lastPrice),\n        priceChange: parseFloat(tickerData.priceChange),\n        priceChangePercent: parseFloat(tickerData.priceChangePercent),\n        volume: parseFloat(tickerData.quoteVolume),\n        count: tickerData.count,\n        status: pair.status,\n        highPrice: parseFloat(tickerData.highPrice),\n        lowPrice: parseFloat(tickerData.lowPrice),\n        openPrice: parseFloat(tickerData.openPrice),\n        prevClosePrice: parseFloat(tickerData.prevClosePrice),\n        weightedAvgPrice: parseFloat(tickerData.weightedAvgPrice),\n        bidPrice: parseFloat(tickerData.bidPrice),\n        askPrice: parseFloat(tickerData.askPrice),\n        bidQty: parseFloat(tickerData.lastQty), // Using lastQty as approximation\n        askQty: parseFloat(tickerData.lastQty),\n      };\n    });\n\n    // Sortowanie po wolumenie (największe najpierw)\n    const sortedAssets = assets.sort((a, b) => b.volume - a.volume);\n\n  logger.debug('trading-pairs-fetched', { count: sortedAssets.length });\n    return sortedAssets;\n\n  } catch (error) {\n  logger.error('trading-pairs-error', error as any);\n    throw new Error(`Failed to fetch trading pairs: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/binanceWSClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1928,1931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1928,1931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Binance WebSocket Client for Kline/Candlestick streams\n// Dedicated client for real-time candlestick data from Binance WebSocket API\n\nexport interface BinanceKlineData {\n  e: string;      // Event type (always \"kline\")\n  E: number;      // Event time (timestamp in milliseconds)\n  s: string;      // Symbol (e.g., \"BTCUSDT\")\n  k: {\n    t: number;    // Kline start time (timestamp in milliseconds)\n    T: number;    // Kline close time (timestamp in milliseconds)\n    s: string;    // Symbol (e.g., \"BTCUSDT\")\n    i: string;    // Interval (e.g., \"1m\")\n    f: number;    // First trade ID\n    L: number;    // Last trade ID\n    o: string;    // Open price\n    c: string;    // Close price\n    h: string;    // High price\n    l: string;    // Low price\n    v: string;    // Base asset volume\n    n: number;    // Number of trades\n    x: boolean;   // Is this kline closed? (true when kline is finalized)\n    q: string;    // Quote asset volume\n    V: string;    // Taker buy base asset volume\n    Q: string;    // Taker buy quote asset volume\n  };\n}\n\nexport type BinanceKlineListener = (data: BinanceKlineData) => void;\n\nexport class BinanceWSClient {\n  private ws: WebSocket | null = null;\n  private listeners: BinanceKlineListener[] = [];\n  private symbol: string;\n  private interval: string;\n  private shouldReconnect = true;\n  private reconnectTimeout: number | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private isDestroyed = false;\n\n  constructor(symbol: string, interval: string = '1m') {\n    this.symbol = symbol.toLowerCase();\n    this.interval = interval;\n    this.connect();\n  }\n\n  private connect() {\n    if (this.isDestroyed) {\n      console.log('[BinanceWSClient] Client is destroyed, skipping connect');\n      return;\n    }\n\n  // Use environment variable for Binance WebSocket URL (tests use process.env)\n  const baseUrl = (typeof process !== 'undefined' && (process as any).env?.VITE_BINANCE_WS_URL) || 'wss://data-stream.binance.vision/ws';\n    const url = `${baseUrl}/${this.symbol}@kline_${this.interval}`;\n    console.log(`[BinanceWSClient] Connecting to ${url}`);\n    console.log(`[BinanceWSClient] Using ${baseUrl.includes('data-stream') ? 'data-stream.binance.vision (optimized for market data)' : 'stream.binance.com (full API)'}`);\n\n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.onopen = () => {\n        console.log(`[BinanceWSClient] Connected to ${url}`);\n        this.reconnectAttempts = 0;\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data: BinanceKlineData = JSON.parse(event.data);\n          if (data.e === 'kline') {\n            this.notifyListeners(data);\n          }\n        } catch (error) {\n          console.error('[BinanceWSClient] Failed to parse message:', error);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('[BinanceWSClient] WebSocket error:', error);\n        console.error('[BinanceWSClient] Connection URL:', url);\n        console.error('[BinanceWSClient] WebSocket readyState:', this.ws?.readyState);\n        \n        // Additional error information\n        if (this.ws?.readyState === WebSocket.CLOSING) {\n          console.warn('[BinanceWSClient] WebSocket is closing');\n        } else if (this.ws?.readyState === WebSocket.CLOSED) {\n          console.warn('[BinanceWSClient] WebSocket is closed');\n        }\n      };\n\n      this.ws.onclose = (event) => {\n        console.log(`[BinanceWSClient] Connection closed: ${event.code} ${event.reason}`);\n        this.ws = null;\n        \n        // Don't attempt reconnection if the close was due to an invalid endpoint (code 1006)\n        if (event.code === 1006) {\n          console.warn('[BinanceWSClient] Connection failed - possibly invalid endpoint or unsupported stream. Check if testnet supports kline streams.');\n          console.warn('[BinanceWSClient] Consider setting VITE_ENABLE_BINANCE_STREAMS=false in development.');\n          this.shouldReconnect = false;\n          return;\n        }\n        \n        if (this.shouldReconnect && !this.isDestroyed && this.reconnectAttempts < this.maxReconnectAttempts) {\n          const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n          console.log(`[BinanceWSClient] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n          \n          this.reconnectTimeout = window.setTimeout(() => {\n            this.reconnectAttempts++;\n            this.connect();\n          }, delay);\n        } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n          console.error('[BinanceWSClient] Max reconnection attempts reached. Giving up.');\n        }\n      };\n\n    } catch (error) {\n      console.error('[BinanceWSClient] Failed to create WebSocket:', error);\n    }\n  }\n\n  private notifyListeners(data: BinanceKlineData) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(data);\n      } catch (error) {\n        console.error('[BinanceWSClient] Error in listener:', error);\n      }\n    });\n  }\n\n  addListener(listener: BinanceKlineListener) {\n    this.listeners.push(listener);\n    console.log(`[BinanceWSClient] Added listener, total: ${this.listeners.length}`);\n  }\n\n  removeListener(listener: BinanceKlineListener) {\n    const index = this.listeners.indexOf(listener);\n    if (index !== -1) {\n      this.listeners.splice(index, 1);\n      console.log(`[BinanceWSClient] Removed listener, total: ${this.listeners.length}`);\n    }\n  }\n\n  destroy() {\n    console.log('[BinanceWSClient] Destroying client');\n    this.isDestroyed = true;\n    this.shouldReconnect = false;\n    \n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    \n    this.listeners = [];\n  }\n\n  // Get current connection state\n  get isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  // Change symbol (creates new connection)\n  changeSymbol(newSymbol: string, newInterval?: string) {\n    this.symbol = newSymbol.toLowerCase();\n    if (newInterval) {\n      this.interval = newInterval;\n    }\n    \n    console.log(`[BinanceWSClient] Changing to ${this.symbol}@kline_${this.interval}`);\n    \n    // Close current connection and create new one\n    if (this.ws) {\n      this.ws.close();\n    }\n    \n    this.reconnectAttempts = 0;\n    this.connect();\n  }\n}\n\nexport default BinanceWSClient;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/getEnvVar.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[781,784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[781,784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// getEnvVar.ts - Helper for environment variables in Vite\n\n// Whitelist dozwolonych kluczy środowiskowych dla bezpieczeństwa\nconst ALLOWED_ENV_KEYS = [\n  'VITE_API_URL',\n  'VITE_WS_URL', \n  'VITE_API_KEY',\n  'VITE_SECRET_KEY',\n  'VITE_AUTH_TOKEN',\n  'MODE',\n  'API_URL',\n  'WS_URL'\n] as const;\n\ntype AllowedEnvKey = typeof ALLOWED_ENV_KEYS[number];\n\nexport function getEnvVar(key: AllowedEnvKey, fallback?: string): string {\n  // Sprawdź czy klucz jest na whitelist\n  if (!ALLOWED_ENV_KEYS.includes(key)) {\n    console.warn(`Environment key '${key}' is not in allowed list`);\n    return fallback ?? '';\n  }\n  \n  // Use Vite's import.meta.env instead of process.env\n  // Try process.env first (tests), then fallback\n  const envValue = (typeof process !== 'undefined' ? (process as any).env?.[key] : undefined) as string | undefined;\n  return envValue ?? fallback ?? '';\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/getViteEnvVar.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":24,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":24,"endColumn":16,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[661,674],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":26,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":26,"endColumn":18,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[827,840],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// getViteEnvVar.ts - tylko import.meta.env, do użycia w kodzie uruchamianym przez Vite\n\n// Whitelist dozwolonych kluczy środowiskowych dla bezpieczeństwa\nconst ALLOWED_VITE_ENV_KEYS = [\n  'VITE_API_URL',\n  'VITE_WS_URL', \n  'VITE_API_KEY',\n  'VITE_SECRET_KEY',\n  'MODE',\n  'BASE_URL',\n  'PROD',\n  'DEV'\n] as const;\n\ntype AllowedViteEnvKey = typeof ALLOWED_VITE_ENV_KEYS[number];\n\nexport function getViteEnvVar(key: AllowedViteEnvKey, fallback?: string): string {\n  // Sprawdź czy klucz jest na whitelist\n  if (!ALLOWED_VITE_ENV_KEYS.includes(key)) {\n    console.warn(`Vite environment key '${key}' is not in allowed list`);\n    return fallback ?? '';\n  }\n  \n  // @ts-ignore\n  if (typeof import.meta !== 'undefined' && typeof import.meta.env !== 'undefined' && Object.prototype.hasOwnProperty.call(import.meta.env, key)) {\n    // @ts-ignore\n    return import.meta.env[key] ?? fallback ?? '';\n  }\n  return fallback ?? '';\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[642,645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[642,645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":34,"column":68,"nodeType":"BlockStatement","messageId":"unexpected","endLine":34,"endColumn":70,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1162,1162],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":35,"column":7,"severity":1,"nodeType":null,"fix":{"range":[1170,1208],"text":" "}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1326,1329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1326,1329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":44,"column":5,"severity":1,"nodeType":null,"fix":{"range":[1456,1494],"text":" "}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1511,1514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1511,1514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1679,1682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1679,1682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1741,1744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1741,1744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1802,1805],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1802,1805],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1864,1867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1864,1867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1927,1930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1927,1930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"// Lightweight leveled logger to control noisy console output.\n// Usage: import { logger } from './logger'; logger.debug('msg');\n// Levels: error < warn < info < debug < trace\n// Configure via VITE_LOG_LEVEL (default 'info') or localStorage.setItem('LOG_LEVEL','debug') for session.\n\ntype LevelName = 'error' | 'warn' | 'info' | 'debug' | 'trace';\n\nconst levelPriority: Record<LevelName, number> = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4,\n};\n\nfunction resolveLevel(): LevelName {\n  const ls = (typeof window !== 'undefined' && (window.localStorage.getItem('LOG_LEVEL') as LevelName)) || null;\n  const env = (import.meta as any).env?.VITE_LOG_LEVEL as LevelName | undefined;\n  const chosen = ls || env || 'info';\n  if (levelPriority[chosen] === undefined) return 'info';\n  return chosen;\n}\n\nlet currentLevel: LevelName = resolveLevel();\n\ndeclare global {\n  interface Window { __setLogLevel?: (lvl: LevelName) => void }\n}\n\nif (typeof window !== 'undefined') {\n  window.__setLogLevel = (lvl: LevelName) => {\n    if (levelPriority[lvl] !== undefined) {\n      currentLevel = lvl;\n      try { window.localStorage.setItem('LOG_LEVEL', lvl); } catch {}\n      // eslint-disable-next-line no-console\n      console.info('[logger] level set to', lvl);\n    }\n  };\n}\n\nfunction log(level: LevelName, prefix: string, args: any[]) {\n  if (levelPriority[level] <= levelPriority[currentLevel]) {\n    const method = level === 'trace' ? 'debug' : level;\n    // eslint-disable-next-line no-console\n    (console as any)[method](`[${prefix}]`, ...args);\n  }\n}\n\nclass Logger {\n  private prefix: string;\n  constructor(prefix: string) {\n    this.prefix = prefix;\n  }\n  error = (...args: any[]) => log('error', this.prefix, args);\n  warn = (...args: any[]) => log('warn', this.prefix, args);\n  info = (...args: any[]) => log('info', this.prefix, args);\n  debug = (...args: any[]) => log('debug', this.prefix, args);\n  trace = (...args: any[]) => log('trace', this.prefix, args);\n  child(suffix: string) { return new Logger(`${this.prefix}:${suffix}`); }\n}\n\nexport const createLogger = (prefix: string) => new Logger(prefix);\nexport const logger = createLogger('app');\n\nexport function setLoggerLevel(lvl: LevelName) {\n  if (levelPriority[lvl] !== undefined) {\n    currentLevel = lvl;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/restClient.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/restClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":173,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3944,3947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3944,3947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":313,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7495,7498],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7495,7498],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7614,7617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7614,7617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":326,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7719,7722],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7719,7722],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9524,9527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9524,9527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport axios from 'axios';\n\nimport { getEnvVar } from './getEnvVar';\n\n\nconst API_BASE_URL = getEnvVar('VITE_API_URL', 'http://localhost:8001');\nconst AUTH_TOKEN = getEnvVar('VITE_AUTH_TOKEN', 'example_admin_token');\n\nexport const api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': `Bearer ${AUTH_TOKEN}`,\n  },\n});\n\n// Typy odpowiedzi zgodne z backendem\nexport interface CommissionRates {\n  maker: string;\n  taker: string;\n  buyer: string;\n  seller: string;\n}\n\nexport interface Balance {\n  asset: string;\n  free: string;\n  locked: string;\n}\n\nexport interface AccountResponse {\n  makerCommission: number;\n  takerCommission: number;\n  buyerCommission: number;\n  sellerCommission: number;\n  commissionRates: CommissionRates;\n  canTrade: boolean;\n  canWithdraw: boolean;\n  canDeposit: boolean;\n  brokered: boolean;\n  requireSelfTradePrevention: boolean;\n  preventSor: boolean;\n  updateTime: number;\n  accountType: string;\n  balances: Balance[];\n  permissions: string[];\n  uid: number;\n  /** Niestandardowe pole backendu, nie występuje w oficjalnym API Binance */\n  limits?: Record<string, number>;\n}\n\nexport interface TickerResponse {\n  symbol: string;\n  price: string;\n  change?: string;\n  changePercent?: string;\n}\n\n\n// Typ odpowiedzi dla historii konta\nexport interface HistoryResponse {\n  history: Array<unknown>; // Doprecyzuj typ po stronie backendu\n}\n\nexport interface OrderbookResponse {\n  symbol?: string;\n  bids: Array<[string, string]>;\n  asks: Array<[string, string]>;\n}\n\nexport interface BotStatusResponse {\n  status: string;\n  running: boolean;\n}\n\nexport interface BotLogsResponse {\n  logs: string[];\n}\n\n// Order Management Types\nexport interface OrderResponse {\n  symbol: string;\n  orderId: number;\n  orderListId: number;\n  clientOrderId: string;\n  price: string;\n  origQty: string;\n  executedQty: string;\n  cummulativeQuoteQty: string;\n  status: string;\n  timeInForce: string;\n  type: string;\n  side: string;\n  stopPrice?: string;\n  icebergQty?: string;\n  time: number;\n  updateTime: number;\n  isWorking: boolean;\n  workingTime?: number;\n  origQuoteOrderQty: string;\n  selfTradePreventionMode?: string;\n}\n\nexport interface OpenOrdersResponse {\n  orders: OrderResponse[];\n}\n\nexport interface OrderHistoryResponse {\n  orders: OrderResponse[];\n}\n\nexport interface OrderStatusResponse {\n  order: OrderResponse;\n}\n\n// Przykładowe funkcje API\nexport async function getAccount() {\n  try {\n    const res = await api.get<AccountResponse>('/account');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n\nexport async function getTicker(symbol: string) {\n  try {\n    const res = await api.get<TickerResponse>(`/ticker?symbol=${encodeURIComponent(symbol)}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n\nexport async function getAccountHistory(symbol: string) {\n  try {\n    const res = await api.get<HistoryResponse>(`/account/history?symbol=${encodeURIComponent(symbol)}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getAccountBalance(asset: string) {\n  try {\n    const res = await api.get<{ balance: string }>(`/account/balance?asset=${encodeURIComponent(asset)}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getOrderbook(symbol: string) {\n  try {\n    const res = await api.get<OrderbookResponse>(`/orderbook?symbol=${symbol}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n// Order Management Functions\nexport async function getOpenOrders(symbol?: string) {\n  try {\n    const url = symbol ? `/orders/open?symbol=${encodeURIComponent(symbol)}` : '/orders/open';\n    // Prosty cache w pamięci (TTL 4s) aby uniknąć spamowania gdy komponent się rerenderuje\n    const cacheKey = `open:${symbol || 'ALL'}`;\n    type CacheEntry = { time: number; data: OpenOrdersResponse };\n    const g = (globalThis as any);\n    g.__OPEN_ORDERS_CACHE = g.__OPEN_ORDERS_CACHE || new Map<string, CacheEntry>();\n    const cache: Map<string, CacheEntry> = g.__OPEN_ORDERS_CACHE;\n    const entry = cache.get(cacheKey);\n    const now = Date.now();\n    if (entry && now - entry.time < 4000) {\n      return entry.data;\n    }\n    const res = await api.get<OpenOrdersResponse>(url);\n    if (res.data) {\n      cache.set(cacheKey, { time: now, data: res.data });\n    }\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getOrdersHistory(\n  symbol: string,\n  limit: number = 100,\n  orderId?: number,\n  startTime?: number,\n  endTime?: number\n) {\n  try {\n    const params = new URLSearchParams({\n      symbol,\n      limit: limit.toString(),\n    });\n    \n    if (orderId) params.append('orderId', orderId.toString());\n    if (startTime) params.append('startTime', startTime.toString());\n    if (endTime) params.append('endTime', endTime.toString());\n\n    const res = await api.get<OrderHistoryResponse>(`/orders/history?${params}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getOrderStatus(orderId: number, symbol: string, origClientOrderId?: string) {\n  try {\n    const params = new URLSearchParams({\n      symbol,\n    });\n    \n    if (origClientOrderId) {\n      params.append('origClientOrderId', origClientOrderId);\n    }\n\n    const res = await api.get<OrderStatusResponse>(`/orders/${orderId}?${params}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n// Alias for compatibility with MarketPanel.tsx\nexport const getOrderBook = getOrderbook;\n\n// Alias for compatibility with MarketPanel.tsx\nexport const getCurrentTicker = getTicker;\n\n// Exchange info and 24hr ticker endpoints\nexport async function getExchangeInfo() {\n  try {\n    const res = await api.get('/exchangeInfo');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function get24hrTicker() {\n  try {\n    const res = await api.get('/24hr');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n// Klines response type (Binance returns arrays of values)\nexport type KlineResponse = [\n  number,  // Open time\n  string,  // Open price\n  string,  // High price\n  string,  // Low price\n  string,  // Close price\n  string,  // Volume\n  number,  // Close time\n  string,  // Quote asset volume\n  number,  // Number of trades\n  string,  // Taker buy base asset volume\n  string   // Taker buy quote asset volume\n];\n\n// Get Klines (candlestick data)\nexport async function getKlines(symbol: string, interval: string = '1m', limit: number = 100) {\n  try {\n    const res = await api.get<KlineResponse[]>(`/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}&limit=${limit}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getBotStatus() {\n  try {\n    const res = await api.get<BotStatusResponse>('/bot/status');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function getBotLogs() {\n  try {\n    const res = await api.get<BotLogsResponse>('/bot/logs');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n// ===== ORDER MANAGEMENT FUNCTIONS =====\n\nexport interface PlaceOrderRequest {\n  symbol: string;\n  side: 'BUY' | 'SELL';\n  type: 'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT';\n  quantity: string;\n  price?: string;\n  timeInForce?: 'GTC' | 'IOC' | 'FOK';\n}\n\nexport interface PlaceOrderResponse {\n  success: boolean;\n  order?: any;\n  error?: string;\n}\n\nexport interface TestOrderResponse {\n  success: boolean;\n  message?: string;\n  test_result?: any;\n  error?: string;\n}\n\nexport interface CancelOrderResponse {\n  success: boolean;\n  cancelled_order?: any;\n  error?: string;\n}\n\nexport async function placeOrder(orderData: PlaceOrderRequest) {\n  try {\n    const res = await api.post<PlaceOrderResponse>('/orders', orderData);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function testOrder(orderData: PlaceOrderRequest) {\n  try {\n    const res = await api.post<TestOrderResponse>('/orders/test', orderData);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nexport async function cancelOrder(orderId: number, symbol: string, origClientOrderId?: string) {\n  try {\n    const params = new URLSearchParams({ symbol });\n    if (origClientOrderId) {\n      params.append('origClientOrderId', origClientOrderId);\n    }\n    \n    const res = await api.delete<CancelOrderResponse>(`/orders/${orderId}?${params}`);\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\n// ===== METRICS FUNCTIONS =====\n\nexport interface MetricsResponse {\n  batchesSent: number;\n  watchdogFallbacks: number;\n  userStreamReconnects: number;\n  keepaliveErrors: number;\n  wsListenerErrors: number;\n  openOrders: number;\n  ordersTotal: number;\n  historySize: number;\n  balancesCount: number;\n  userConnections: number;\n  lastEventAgeMs: number | null;\n  lastKeepAliveAgeMs: number | null;\n  connectionErrors: number;\n  userStreamRestarts: number;\n  listenKeyActive: boolean;\n  avgEventLatencyMs: number | null;\n}\n\nexport async function getMetrics() {\n  try {\n    const res = await api.get<MetricsResponse>('/metrics/basic');\n    return res.data;\n  } catch (err) {\n    handleError(err);\n  }\n}\n\nfunction handleError(error: unknown): never {\n  // Obsługa błędów Axios\n  if (typeof error === 'object' && error !== null && 'isAxiosError' in error && (error as { isAxiosError?: boolean }).isAxiosError) {\n    const err = error as any;\n    // Loguj szczegóły do konsoli\n    console.error('API error:', err);\n    // Wyświetl szczegóły użytkownikowi\n    throw new Error(err.response?.data?.detail || err.message || 'Błąd API');\n  }\n  // Obsługa zwykłych błędów JS\n  if (error instanceof Error) {\n    throw error;\n  }\n  console.error('Unknown error:', error);\n  throw new Error('Unknown error');\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/testConnection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/services/wsClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[697,700],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[697,700],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2615,2618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2615,2618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2704,2707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2704,2707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2793,2796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2793,2796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":210,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":210,"endColumn":21},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":210,"column":23,"nodeType":"BlockStatement","messageId":"unexpected","endLine":210,"endColumn":25,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6825,6825],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced WebSocket Client z exponential backoff, connection states i heartbeat\nimport { createLogger } from './logger';\n\nexport const ConnectionState = {\n  DISCONNECTED: 'DISCONNECTED',\n  CONNECTING: 'CONNECTING', \n  CONNECTED: 'CONNECTED',\n  RECONNECTING: 'RECONNECTING',\n  ERROR: 'ERROR',\n  CLOSING: 'CLOSING'\n} as const;\n\nexport type ConnectionState = typeof ConnectionState[keyof typeof ConnectionState];\n\nexport type WSMessage =\n  | { type: 'ticker', symbol: string, price: string, change?: string, changePercent?: string }\n  | { type: 'orderbook', symbol: string, bids: [string, string][], asks: [string, string][] }\n  | { type: 'log', message: string }\n  | { type: 'bot_status', status: any, running: boolean }\n  | { type: 'ping' }\n  | { type: 'pong' }\n  | { type: string, [key: string]: unknown };\n\nexport type WSListener = (msg: WSMessage) => void;\nexport type StateChangeListener = (state: ConnectionState, error?: string) => void;\n\nexport interface WSClientOptions {\n  reconnectInterval?: number;\n  maxReconnectInterval?: number;\n  maxReconnectAttempts?: number;\n  heartbeatInterval?: number;\n  heartbeatTimeout?: number;\n  debug?: boolean;\n}\n\nexport class EnhancedWSClient {\n  private logger = createLogger('ws');\n  private url: string;\n  private ws: WebSocket | null = null;\n  private listeners: WSListener[] = [];\n  private stateListeners: StateChangeListener[] = [];\n  \n  // Connection state\n  private state: ConnectionState = ConnectionState.DISCONNECTED;\n  private shouldReconnect = true;\n  private reconnectAttempts = 0;\n  private reconnectTimeout: number | null = null;\n  \n  // Options with defaults\n  private options: Required<WSClientOptions>;\n  \n  // Heartbeat\n  private heartbeatInterval: number | null = null;\n  private heartbeatTimeout: number | null = null;\n  private lastPongTime = Date.now();\n  \n  // Debouncing for React Strict Mode\n  private connectDebounceTimeout: number | null = null;\n  private isDestroyed = false;\n  \n  // Message queue for sends attempted before OPEN\n  private pendingMessages: string[] = [];\n  private waiters: { resolve: () => void; reject: (e: Error) => void; timeoutId: number }[] = [];\n\n  constructor(url: string, options: WSClientOptions = {}) {\n    this.url = url;\n    this.options = {\n      reconnectInterval: 2000,\n      maxReconnectInterval: 30000,\n      maxReconnectAttempts: 10,\n      heartbeatInterval: 30000,\n      heartbeatTimeout: 5000,\n      debug: false, // Changed default to false for production performance\n      ...options\n    };\n    \n  this.log('creating', url);\n    this.debouncedConnect();\n  }\n\n  private log(message: string, ...args: any[]) { this.logger.trace(message, ...args); }\n  private warn(message: string, ...args: any[]) { this.logger.warn(message, ...args); }\n  private error(message: string, ...args: any[]) { this.logger.error(message, ...args); }\n\n  private setState(newState: ConnectionState, error?: string) {\n    if (this.state !== newState) {\n  this.log(`state ${this.state} -> ${newState}${error ? ` (${error})` : ''}`);\n      this.state = newState;\n      this.notifyStateListeners(newState, error);\n    }\n  }\n\n  private notifyStateListeners(state: ConnectionState, error?: string) {\n    this.stateListeners.forEach(listener => {\n      try {\n        listener(state, error);\n      } catch (e) {\n        this.error('[WSClient] Error in state listener:', e);\n      }\n    });\n  }\n\n  private debouncedConnect() {\n    if (this.connectDebounceTimeout) {\n      clearTimeout(this.connectDebounceTimeout);\n    }\n    \n    this.connectDebounceTimeout = window.setTimeout(() => {\n      if (!this.isDestroyed) {\n        this.connect();\n      }\n    }, 100);\n  }\n\n  private connect() {\n    if (this.isDestroyed) return;\n    \n    if (this.state === ConnectionState.CONNECTING || this.state === ConnectionState.CONNECTED) {\n  this.log('already-connecting');\n      return;\n    }\n\n    if (this.reconnectAttempts >= this.options.maxReconnectAttempts) {\n      this.setState(ConnectionState.ERROR, `Max reconnect attempts (${this.options.maxReconnectAttempts}) reached`);\n      return;\n    }\n\n    this.setState(this.reconnectAttempts > 0 ? ConnectionState.RECONNECTING : ConnectionState.CONNECTING);\n    \n    try {\n      this.ws = new WebSocket(this.url);\n      \n      this.ws.onopen = () => {\n        if (this.isDestroyed) return;\n        \n  this.log('connected', this.url);\n        this.reconnectAttempts = 0;\n        this.lastPongTime = Date.now();\n        this.setState(ConnectionState.CONNECTED);\n        this.startHeartbeat();\n        // Flush queued messages\n        if (this.pendingMessages.length) {\n          this.log('flush-queue', this.pendingMessages.length);\n          for (const msg of this.pendingMessages) {\n            try { this.ws!.send(msg); } catch (e) { this.warn('queued-send-failed', e); }\n          }\n          this.pendingMessages = [];\n        }\n        // Resolve waiters\n        this.waiters.forEach(w => { clearTimeout(w.timeoutId); w.resolve(); });\n        this.waiters = [];\n      };\n\n      this.ws.onmessage = (event) => {\n        if (this.isDestroyed) return;\n        \n        try {\n          const data = JSON.parse(event.data);\n          \n          // Handle heartbeat\n          if (data.type === 'pong') {\n            this.lastPongTime = Date.now();\n            this.log('pong');\n            return;\n          }\n          \n          if (data.type === 'ping') {\n            this.send({ type: 'pong' });\n            return;\n          }\n\n          this.log('message', data.type);\n          this.notifyListeners(data);\n        } catch (e) {\n          this.warn('parse-failed', event.data, e);\n        }\n      };\n\n      this.ws.onerror = (event) => {\n        if (this.isDestroyed) return;\n        \n  this.error('ws-error', event);\n        this.setState(ConnectionState.ERROR, 'WebSocket connection error');\n      };\n\n      this.ws.onclose = (event) => {\n        if (this.isDestroyed) return;\n        \n  this.warn('closed', event.code, event.reason);\n        this.stopHeartbeat();\n  // Reject waiters\n  this.waiters.forEach(w => { clearTimeout(w.timeoutId); w.reject(new Error('WebSocket closed before open')); });\n  this.waiters = [];\n        \n        if (event.code === 1000) {\n          this.setState(ConnectionState.DISCONNECTED);\n          return;\n        }\n\n        // Specjalne traktowanie code 1005 (no status) – często oznacza przerwane połączenie/proxy problem\n        if (event.code === 1005) {\n          // Heurystyka: jeśli URL wskazuje na dev server (5173) a nie backend port, spróbuj jednorazowo podmienić host\n          try {\n            const u = new URL(this.url);\n            if (/5173$/.test(u.port)) {\n              const alt = this.url.replace(/5173/, '8001');\n              this.warn('code1005-dev-port', this.url, '->', alt);\n              this.url = alt;\n            }\n          } catch (_) {}\n        }\n\n        this.setState(ConnectionState.ERROR, `Connection closed unexpectedly (${event.code})`);\n        this.scheduleReconnect();\n      };\n      \n    } catch (e) {\n      this.error('[WSClient] Failed to create WebSocket:', e);\n      this.setState(ConnectionState.ERROR, 'Failed to create WebSocket connection');\n      this.scheduleReconnect();\n    }\n  }\n\n  private scheduleReconnect() {\n    if (!this.shouldReconnect || this.isDestroyed) return;\n    \n    const delay = Math.min(\n      this.options.reconnectInterval * Math.pow(2, this.reconnectAttempts),\n      this.options.maxReconnectInterval\n    );\n    \n  this.log('schedule-reconnect', { delay, attempt: this.reconnectAttempts + 1 });\n    \n    this.reconnectTimeout = window.setTimeout(() => {\n      if (!this.isDestroyed) {\n        this.reconnectAttempts++;\n        this.connect();\n      }\n    }, delay);\n  }\n\n  private startHeartbeat() {\n    this.stopHeartbeat();\n    \n    this.heartbeatInterval = window.setInterval(() => {\n      if (this.isDestroyed) return;\n      \n      const timeSinceLastPong = Date.now() - this.lastPongTime;\n      \n      if (timeSinceLastPong > this.options.heartbeatTimeout + this.options.heartbeatInterval) {\n  this.warn('heartbeat-timeout');\n        this.ws?.close();\n        return;\n      }\n      \n      if (this.ws?.readyState === WebSocket.OPEN) {\n  this.send({ type: 'ping' }); this.log('ping');\n      }\n    }, this.options.heartbeatInterval);\n  }\n\n  private stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n    \n    if (this.heartbeatTimeout) {\n      clearTimeout(this.heartbeatTimeout);\n      this.heartbeatTimeout = null;\n    }\n  }\n\n  private notifyListeners(data: WSMessage) {\n    // Process listeners asynchronously to avoid blocking main thread\n    requestAnimationFrame(() => {\n      this.listeners.forEach(listener => {\n        try {\n          listener(data);\n        } catch (e) {\n    this.error('listener-error', e);\n        }\n      });\n    });\n  }\n\n  // Public API\n  public getState(): ConnectionState {\n    return this.state;\n  }\n\n  public isConnected(): boolean {\n    return this.state === ConnectionState.CONNECTED;\n  }\n\n  public send(data: object): boolean {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(data));\n      return true;\n    }\n    // Queue message for later\n    const payload = JSON.stringify(data);\n    this.pendingMessages.push(payload);\n  this.log('queue', this.state);\n    return false; // not yet sent\n  }\n\n  /** Returns promise resolved when socket is OPEN (or rejects after timeout). */\n  public waitUntilOpen(timeoutMs = 5000): Promise<void> {\n    if (this.ws?.readyState === WebSocket.OPEN) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      const timeoutId = window.setTimeout(() => {\n        this.waiters = this.waiters.filter(w => w.timeoutId !== timeoutId);\n        reject(new Error('waitUntilOpen timeout'));\n      }, timeoutMs);\n      this.waiters.push({ resolve, reject, timeoutId });\n    });\n  }\n\n  public addListener(listener: WSListener) {\n    this.listeners.push(listener);\n  }\n\n  public removeListener(listener: WSListener) {\n    this.listeners = this.listeners.filter(l => l !== listener);\n  }\n\n  public addStateListener(listener: StateChangeListener) {\n    this.stateListeners.push(listener);\n  }\n\n  public removeStateListener(listener: StateChangeListener) {\n    this.stateListeners = this.stateListeners.filter(l => l !== listener);\n  }\n\n  public reconnect() {\n  this.log('manual-reconnect');\n    this.reconnectAttempts = 0;\n    this.close();\n    setTimeout(() => this.connect(), 100);\n  }\n\n  public close() {\n  this.log('closing');\n    this.shouldReconnect = false;\n    this.setState(ConnectionState.CLOSING);\n    \n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    if (this.connectDebounceTimeout) {\n      clearTimeout(this.connectDebounceTimeout);\n      this.connectDebounceTimeout = null;\n    }\n    \n    this.stopHeartbeat();\n    this.ws?.close(1000, 'Client requested close');\n    this.ws = null;\n    this.setState(ConnectionState.DISCONNECTED);\n  }\n\n  public destroy() {\n  this.log('destroy');\n    this.isDestroyed = true;\n    this.close();\n    this.listeners = [];\n    this.stateListeners = [];\n  }\n}\n\n// Utility function for connection state display\nexport function getConnectionStateDisplay(state: ConnectionState): { text: string; color: string; icon: string } {\n  switch (state) {\n    case ConnectionState.CONNECTED:\n      return { text: 'Połączony', color: '#10B981', icon: '🟢' };\n    case ConnectionState.CONNECTING:\n      return { text: 'Łączenie...', color: '#F59E0B', icon: '🟡' };\n    case ConnectionState.RECONNECTING:\n      return { text: 'Ponowne łączenie...', color: '#F59E0B', icon: '🔄' };\n    case ConnectionState.DISCONNECTED:\n      return { text: 'Rozłączony', color: '#6B7280', icon: '⚫' };\n    case ConnectionState.ERROR:\n      return { text: 'Błąd połączenia', color: '#EF4444', icon: '🔴' };\n    case ConnectionState.CLOSING:\n      return { text: 'Zamykanie...', color: '#6B7280', icon: '⏹️' };\n    default:\n      return { text: 'Nieznany', color: '#6B7280', icon: '❓' };\n  }\n}\n\nexport default EnhancedWSClient;","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/setupTests.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1033,1036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1033,1036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1063,1066],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1063,1066],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1519,1522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1519,1522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1546,1549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1546,1549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2649,2652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2649,2652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2673,2676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2673,2676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2846,2849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2846,2849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom';\n\n// Mock dla HTMLCanvasElement.getContext (Chart.js)\nObject.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n  value: () => {\n    // Można rozbudować mock jeśli testy będą tego wymagać\n    return {\n      fillRect: () => {},\n      clearRect: () => {},\n      getImageData: (_x: number, _y: number, w: number, h: number) => ({ data: new Array(w * h * 4) }),\n      putImageData: () => {},\n      createImageData: () => [],\n      setTransform: () => {},\n      drawImage: () => {},\n      save: () => {},\n      fillText: () => {},\n      restore: () => {},\n      beginPath: () => {},\n      moveTo: () => {},\n      lineTo: () => {},\n      closePath: () => {},\n      stroke: () => {},\n      translate: () => {},\n      scale: () => {},\n      rotate: () => {},\n      arc: () => {},\n      fill: () => {},\n      measureText: () => ({ width: 0 }),\n      transform: () => {},\n      rect: () => {},\n      clip: () => {},\n    };\n  },\n});\n\n// Provide minimal env vars via process.env for tests\n(process as any).env = {\n  ...(process as any).env,\n  NODE_ENV: 'test',\n  VITE_API_URL: 'http://localhost:8001',\n  VITE_WS_URL: 'ws://localhost:8001/ws',\n  VITE_ENABLE_BINANCE_STREAMS: 'false',\n  VITE_MARKET_QUOTES: 'USDT,BTC,ETH,BNB',\n  VITE_MAX_TICKER_SUBS: '100'\n};\n\n// Mock global ResizeObserver for Mantine/ScrollArea\nglobal.ResizeObserver = class {\n  observe() {}\n  unobserve() {}\n  disconnect() {}\n};\n\n// Global fetch mock (dla komponentów używających secureApiCall / fetch)\nif (!(global as any).fetch) {\n  (global as any).fetch = jest.fn(async () => ({\n    ok: true,\n    json: async () => ({\n      // Zwracamy strukturę obsługującą zarówno bot/config jak i bot/strategies\n      config: {\n        type: 'simple_ma',\n        symbol: 'BTCUSDT',\n        timeframe: '1m',\n        parameters: {},\n        risk_management: {\n          max_position_size: 1000,\n          stop_loss_percentage: 2,\n          take_profit_percentage: 5,\n        },\n      },\n      strategies: {\n        simple_ma: { name: 'Simple MA' },\n        rsi: { name: 'RSI' },\n      },\n    }),\n  }));\n}\n\n// ================== Console Suppression ==================\nconst originalConsole = { ...console };\nconst SUPPRESSED_PATTERNS: RegExp[] = [\n  /\\[BinanceAPI\\] Failed to fetch trading pairs/,\n  /An update to .* inside a test was not wrapped in act/,\n  /Setting up WebSocket for/,\n  /WebSocket state changed:/,\n  /Subscribing to .* via existing WebSocket/,\n  // Szumowe logi panelu rynku i hooka wykresu (powtarzalne przy każdym teście)\n  /^\\[MarketPanel]/,\n  /^\\[useLightweightChart]/,\n];\n\n(['log','error','warn'] as const).forEach(level => {\n  (console as any)[level] = (...args: any[]) => {\n    const msg = args[0];\n    if (typeof msg === 'string' && SUPPRESSED_PATTERNS.some(r => r.test(msg))) {\n      return; // swallow\n    }\n    (originalConsole as any)[level](...args);\n  };\n});\n\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/store/userStream.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[464,467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[464,467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[575,578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[575,578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[611,614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[611,614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[656,659],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[656,659],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1481,1484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1481,1484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1522,1525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1522,1525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2857,2860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2857,2860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2898,2901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2898,2901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4138,4141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4138,4141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4183,4186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4183,4186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5337,5340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5337,5340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { render, act, waitFor } from '@testing-library/react';\nimport { UserStreamProvider, useUserStream } from './userStream';\n\n// Mock WebSocket\nconst mockWebSocket = {\n  close: jest.fn(),\n  send: jest.fn(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn(),\n  readyState: 0, // CONNECTING\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n};\n\nglobal.WebSocket = jest.fn().mockImplementation(() => mockWebSocket) as any;\n\n// Test component to access userStream context\nconst TestComponent: React.FC<{\n  onStateChange?: (state: any) => void;\n  onAddPending?: (fn: any) => void;\n  onAddOptimisticCancel?: (fn: any) => void;\n}> = ({ onStateChange, onAddPending, onAddOptimisticCancel }) => {\n  const { state, addPendingOrder, addOptimisticCancel } = useUserStream();\n  \n  React.useEffect(() => {\n    onStateChange?.(state);\n  }, [state, onStateChange]);\n  \n  React.useEffect(() => {\n    onAddPending?.(addPendingOrder);\n    onAddOptimisticCancel?.(addOptimisticCancel);\n  }, [addPendingOrder, addOptimisticCancel, onAddPending, onAddOptimisticCancel]);\n  \n  return <div data-testid=\"test-component\">Test</div>;\n};\n\ndescribe('UserStream Optimistic Operations', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n  });\n\n  describe('addPendingOrder', () => {\n    it('should add pending order and remove it after timeout', async () => {\n      const states: any[] = [];\n      let addPendingOrderFn: any;\n\n      render(\n        <UserStreamProvider>\n          <TestComponent \n            onStateChange={(state) => states.push({ ...state })}\n            onAddPending={(fn) => { addPendingOrderFn = fn; }}\n          />\n        </UserStreamProvider>\n      );\n\n      const testOrder = {\n        orderId: 12345,\n        clientOrderId: 'test_123',\n        symbol: 'BTCUSDT',\n        side: 'BUY',\n        type: 'LIMIT',\n        price: '50000',\n        origQty: '0.001',\n        executedQty: '0',\n        status: 'NEW'\n      };\n\n      // Add pending order\n      act(() => {\n        addPendingOrderFn(testOrder, 1000); // 1s timeout for test\n      });\n\n      // Check that order was added with PENDING status\n      await waitFor(() => {\n        const lastState = states[states.length - 1];\n        expect(lastState.openOrders[12345]).toBeDefined();\n        expect(lastState.openOrders[12345].status).toBe('PENDING');\n      });\n\n      // Fast forward time past timeout\n      act(() => {\n        jest.advanceTimersByTime(1100);\n      });\n\n      // Check that order was removed\n      await waitFor(() => {\n        const lastState = states[states.length - 1];\n        expect(lastState.openOrders[12345]).toBeUndefined();\n      });\n    });\n\n    it('should keep order if real executionReport arrives before timeout', async () => {\n      const states: any[] = [];\n      let addPendingOrderFn: any;\n\n      render(\n        <UserStreamProvider>\n          <TestComponent \n            onStateChange={(state) => states.push({ ...state })}\n            onAddPending={(fn) => { addPendingOrderFn = fn; }}\n          />\n        </UserStreamProvider>\n      );\n\n      const testOrder = {\n        orderId: 12345,\n        clientOrderId: 'test_123',\n        symbol: 'BTCUSDT',\n        side: 'BUY',\n        status: 'NEW'\n      };\n\n      // Add pending order\n      act(() => {\n        addPendingOrderFn(testOrder, 5000);\n      });\n\n      // Simulate real executionReport (would come from WebSocket)\n      // This would be handled by the order_store_batch handler in real scenario\n      // For test, we need to simulate this differently since we don't have full WS mock\n\n      // Fast forward time but not past timeout\n      act(() => {\n        jest.advanceTimersByTime(1000);\n      });\n\n      // Order should still exist (timeout not reached)\n      await waitFor(() => {\n        const lastState = states[states.length - 1];\n        expect(lastState.openOrders[12345]).toBeDefined();\n      });\n    });\n  });\n\n  describe('addOptimisticCancel', () => {\n    it('should mark order as CANCELED and rollback after timeout', async () => {\n      const states: any[] = [];\n      let addOptimisticCancelFn: any;\n\n      render(\n        <UserStreamProvider>\n          <TestComponent \n            onStateChange={(state) => states.push({ ...state })}\n            onAddOptimisticCancel={(fn) => { addOptimisticCancelFn = fn; }}\n          />\n        </UserStreamProvider>\n      );\n\n      // First, simulate having an open order in state  \n      // Note: In real scenario, this would come from orders_snapshot\n      // For this test, we just verify the function handles missing orders gracefully\n      \n      // Apply optimistic cancel\n      act(() => {\n        addOptimisticCancelFn(12345, 1000); // 1s timeout for test\n      });\n\n      // Fast forward time past timeout\n      act(() => {\n        jest.advanceTimersByTime(1100);\n      });\n\n      // Since we don't have initial order in state, function should handle gracefully\n      // In real scenario, this would rollback the status\n    });\n\n    it('should not rollback if WebSocket delta arrives before timeout', async () => {\n      // This test would require more complex mocking of the WebSocket message handling\n      // For now, we verify the function exists and doesn't throw\n      let addOptimisticCancelFn: any;\n\n      render(\n        <UserStreamProvider>\n          <TestComponent \n            onAddOptimisticCancel={(fn) => { addOptimisticCancelFn = fn; }}\n          />\n        </UserStreamProvider>\n      );\n\n      expect(() => {\n        addOptimisticCancelFn(12345, 1000);\n      }).not.toThrow();\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/store/userStream.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[537,540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[537,540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[559,562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[559,562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":180,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":183,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[896,899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[896,899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[978,981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[978,981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1229,1232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1229,1232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1340,1343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1340,1343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":149,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5584,5587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5584,5587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'wsBase' is never reassigned. Use 'const' instead.","line":157,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":157,"endColumn":15,"fix":{"range":[5970,6030],"text":"const wsBase = rawBase.replace(/\\s+/g,'').replace(/\\/+$/, '');"}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-console').","line":173,"column":5,"severity":1,"nodeType":null,"fix":{"range":[6742,6780],"text":" "}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7074,7077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7074,7077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":289,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":289,"endColumn":30}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":1,"source":"import React, { useContext, useEffect, useMemo, useRef, useState, useCallback } from 'react';\nimport EnhancedWSClient, { ConnectionState } from '../services/wsClient';\n\n// Typy odpowiadające protokołowi WEBSOCKET_PROTOCOL.md\ninterface OrderExternal {\n  orderId: number;\n  clientOrderId?: string;\n  symbol: string;\n  side: string;\n  type?: string;\n  timeInForce?: string;\n  price?: string;\n  origQty?: string;\n  executedQty?: string;\n  cummulativeQuoteQty?: string;\n  avgPrice?: string;\n  status: string;\n  updateTime?: number;\n  fills?: any[];\n  [k: string]: any;\n}\n\ninterface BalanceExternal { asset: string; free: string; locked: string; }\n\ntype UserWSMessage =\n  | { type: 'welcome'; ts: number; message: string }\n  | { type: 'orders_snapshot'; openOrders: OrderExternal[]; balances: BalanceExternal[]; history?: OrderExternal[]; lastEventAgeMs?: number|null; fallback?: boolean; mergeStats?: any; ts: number }\n  | { type: 'order_store_batch'; schemaVersion: number; events: any[]; batchSize: number; ts: number; lastEventAgeMs?: number|null }\n  | { type: 'user_heartbeat'; ts: number; lastEventAgeMs?: number|null }\n  | { type: 'system'; level: string; message: string; ts: number; lastEventAgeMs?: number|null; mergeStats?: any }\n  | { type: 'pong'; ts: number }\n  | { type: 'error'; message: string }\n  | { type: string; [k: string]: any };\n\ninterface UserStreamState {\n  connectionState: ConnectionState;\n  openOrders: Record<number, OrderExternal>;\n  balances: Record<string, BalanceExternal>;\n  history: OrderExternal[]; // limited snapshot\n  lastSnapshotTs?: number;\n  lastEventAgeMs?: number|null;\n  freshnessMs?: number|null; // dynamic client computed\n  systemMessages: { level: string; message: string; ts: number }[];\n  schemaVersion?: number;\n  fallback?: boolean;\n}\n\nconst UserStreamContext = React.createContext<{\n  state: UserStreamState;\n  sendResnapshot: () => void;\n  getFreshnessCategory: () => 'green'|'yellow'|'red'|'unknown';\n  addPendingOrder: (order: OrderExternal, timeoutMs?: number) => void;\n  addOptimisticCancel: (orderId: number, timeoutMs?: number) => void;\n} | null>(null);\n\nexport const UserStreamProvider: React.FC<{ baseUrl?: string; children: React.ReactNode }> = ({ baseUrl = '', children }) => {\n  // DEBUG / DIAGNOSTYKA: uspójnienie URL oraz dodatkowe logi aby zidentyfikować brak połączenia /ws/user\n\n  // Dodaj tymczasowe zlecenie (PENDING) do openOrders, rollback po timeout jeśli nie pojawi się NEW/REJECTED\n  const addPendingOrder = useCallback((order: OrderExternal, timeoutMs: number = 15000) => {\n    setState((s: UserStreamState) => {\n      const key = order.orderId ?? order.clientOrderId ?? Math.random();\n      return {\n        ...s,\n        openOrders: {\n          ...s.openOrders,\n          [key]: { ...order, status: 'PENDING' }\n        }\n      };\n    });\n    setTimeout(() => {\n      setState((s: UserStreamState) => {\n        const key = order.orderId ?? order.clientOrderId;\n        const found = Object.values(s.openOrders).find((o: OrderExternal) => (o.clientOrderId === order.clientOrderId) && o.status === 'PENDING');\n        if (found && key) {\n          const newOpen = { ...s.openOrders };\n          delete newOpen[key];\n          return { ...s, openOrders: newOpen };\n        }\n        return s;\n      });\n    }, timeoutMs);\n  }, []);\n\n  // Optymistycznie oznacz zlecenie jako CANCELED, rollback po timeout jeśli nie przyjdzie delta z WebSocket\n  const addOptimisticCancel = useCallback((orderId: number, timeoutMs: number = 10000) => {\n    // Zapisz oryginalny status dla potencjalnego rollback\n    let originalOrder: OrderExternal | null = null;\n    setState((s: UserStreamState) => {\n      originalOrder = s.openOrders[orderId] || null;\n      if (!originalOrder) return s; // Nie ma zlecenia do anulowania\n      \n      return {\n        ...s,\n        openOrders: {\n          ...s.openOrders,\n          [orderId]: { ...originalOrder, status: 'CANCELED' }\n        }\n      };\n    });\n\n    // Rollback po timeout jeśli WebSocket nie potwierdzi anulowania\n    setTimeout(() => {\n      if (originalOrder) {\n        setState((s: UserStreamState) => {\n          const currentOrder = s.openOrders[orderId];\n          // Rollback tylko jeśli nadal ma status CANCELED (nie było delty z WebSocket)\n          if (currentOrder && currentOrder.status === 'CANCELED' && currentOrder.updateTime === originalOrder!.updateTime) {\n            return {\n              ...s,\n              openOrders: {\n                ...s.openOrders,\n                [orderId]: originalOrder!\n              }\n            };\n          }\n          return s;\n        });\n      }\n    }, timeoutMs);\n  }, []);\n  const [state, setState] = useState<UserStreamState>({\n    connectionState: ConnectionState.DISCONNECTED,\n    openOrders: {},\n    balances: {},\n    history: [],\n    systemMessages: []\n  });\n\n  const wsRef = useRef<EnhancedWSClient | null>(null);\n  const lastUpdateMonotonic = useRef<number>(performance.now());\n  const lastEventAgeAtReceive = useRef<number|null>(null);\n\n  // Dynamic freshness updater\n  useEffect(() => {\n    const id = setInterval(() => {\n      if (lastEventAgeAtReceive.current != null) {\n        const elapsed = performance.now() - lastUpdateMonotonic.current; // ms since last message with lastEventAgeMs\n        const freshness = lastEventAgeAtReceive.current + elapsed;\n        setState(s => ({ ...s, freshnessMs: freshness }));\n      }\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  // Connect WS\n  useEffect(() => {\n    if (wsRef.current) return; // already connected\n    const envBase = (import.meta as any).env?.VITE_WS_URL as string | undefined;\n    let rawBase = baseUrl || envBase;\n    if (!rawBase) {\n      const loc = window.location;\n      const assumedBackend = loc.hostname === 'localhost' ? 'localhost:8001' : loc.host;\n      rawBase = `${loc.protocol === 'https:' ? 'wss' : 'ws'}://${assumedBackend}`;\n    }\n    // Normalizacja bazowego URL aby uniknąć duplikacji segmentów\n    let wsBase = rawBase.replace(/\\s+/g,'').replace(/\\/+$/, '');\n    // Jeśli ktoś podał już pełny endpoint /ws/user to użyj jak jest\n    let finalUrl: string;\n    if (/\\/ws\\/user$/i.test(wsBase)) {\n      finalUrl = wsBase; // już kompletny\n    } else if (/\\/ws$/i.test(wsBase)) {\n      finalUrl = wsBase + '/user';\n    } else if (/\\/user$/i.test(wsBase) && !/\\/ws\\/user$/i.test(wsBase)) {\n      // Zamień końcowe /user na /ws/user\n      finalUrl = wsBase.replace(/\\/user$/i, '/ws/user');\n    } else {\n      finalUrl = wsBase + '/ws/user';\n    }\n    // Ochrona przed przypadkową podwójną sekwencją /ws/user/ws/user\n    finalUrl = finalUrl.replace(/(\\/ws\\/user)+(\\/ws\\/user)+/gi, '/ws/user');\n    // Log diagnostyczny (nie używamy console.debug by widoczne było domyślnie)\n    // eslint-disable-next-line no-console\n    console.log('[UserStream] Connecting to', finalUrl, '(raw base:', rawBase, ')');\n    const client = new EnhancedWSClient(finalUrl, { debug: true });\n    wsRef.current = client;\n    client.addStateListener(cs => setState(s => ({ ...s, connectionState: cs })));\n    client.addListener((raw: any) => {\n      // Process heavy operations asynchronously to avoid blocking main thread\n      setTimeout(() => {\n        const msg = raw as UserWSMessage;\n        if ('lastEventAgeMs' in msg) {\n          if (typeof msg.lastEventAgeMs === 'number') {\n              lastEventAgeAtReceive.current = msg.lastEventAgeMs;\n              lastUpdateMonotonic.current = performance.now();\n          }\n        }\n        switch (msg.type) {\n          case 'orders_snapshot': {\n            // Use more efficient object creation\n            const openMap: Record<number, OrderExternal> = {};\n            const balMap: Record<string, BalanceExternal> = {};\n            \n            // Process in smaller chunks to avoid blocking\n            const processOrders = () => {\n              if (msg.openOrders) {\n                for (const o of msg.openOrders) {\n                  if (o.orderId != null) openMap[o.orderId] = o;\n                }\n              }\n            };\n            \n            const processBalances = () => {\n              if (msg.balances) {\n                for (const b of msg.balances) {\n                  balMap[b.asset] = b;\n                }\n              }\n            };\n            \n            processOrders();\n            processBalances();\n            \n            setState(s => ({\n              ...s,\n              openOrders: openMap,\n              balances: balMap,\n              history: msg.history || s.history,\n              lastSnapshotTs: Date.now(),\n              lastEventAgeMs: msg.lastEventAgeMs ?? s.lastEventAgeMs,\n              fallback: msg.fallback === true\n            }));\n            break;\n          }\n        case 'order_store_batch': {\n          // Process asynchronously to avoid blocking main thread\n          setTimeout(() => {\n            setState(s => {\n              const openOrders = { ...s.openOrders };\n              const balances = { ...s.balances };\n              \n              for (const ev of msg.events || []) {\n                if (ev.type === 'order_delta' && ev.order?.orderId != null) {\n                  openOrders[ev.order.orderId] = { ...openOrders[ev.order.orderId], ...ev.order };\n                  if (!['NEW','PARTIALLY_FILLED'].includes(ev.order.status)) {\n                    if (['FILLED','CANCELED','REJECTED','EXPIRED'].includes(ev.order.status)) {\n                      delete openOrders[ev.order.orderId];\n                    }\n                  }\n                } else if (ev.type === 'balance_delta') {\n                  (ev.balances || []).forEach((b: BalanceExternal) => { balances[b.asset] = b; });\n                }\n              }\n              return { ...s, openOrders, balances, lastEventAgeMs: msg.lastEventAgeMs ?? s.lastEventAgeMs, schemaVersion: msg.schemaVersion };\n            });\n          }, 0);\n          break;\n        }\n        case 'user_heartbeat': {\n          setState(s => ({ ...s, lastEventAgeMs: msg.lastEventAgeMs ?? s.lastEventAgeMs }));\n          break;\n        }\n        case 'system': {\n          setState(s => ({ ...s, systemMessages: [...s.systemMessages.slice(-19), { level: msg.level, message: msg.message, ts: Date.now() }] }));\n          break;\n        }\n        default:\n          break;\n      }\n      }, 0); // Close setTimeout\n    });\n    return () => { client.destroy(); };\n  }, [baseUrl]);\n\n  const sendResnapshot = useCallback(() => {\n    const ws = wsRef.current;\n    if (!ws) return;\n    if (ws.isConnected()) {\n      ws.send({ type: 'resnapshot' });\n    } else {\n      ws.waitUntilOpen(4000).then(() => ws.send({ type: 'resnapshot' })).catch(() => {\n        // silently ignore timeout\n      });\n    }\n  }, []);\n\n  const getFreshnessCategory = useCallback(() => {\n    const f = state.freshnessMs ?? state.lastEventAgeMs;\n    if (f == null) return 'unknown';\n    if (f < 5000) return 'green';\n    if (f < 15000) return 'yellow';\n    return 'red';\n  }, [state.freshnessMs, state.lastEventAgeMs]);\n\n  const value = useMemo(() => ({ state, sendResnapshot, getFreshnessCategory, addPendingOrder, addOptimisticCancel }), [state, sendResnapshot, getFreshnessCategory, addPendingOrder, addOptimisticCancel]);\n  return <UserStreamContext.Provider value={value}>{children}</UserStreamContext.Provider>;\n};\n\nexport function useUserStream() {\n  const ctx = useContext(UserStreamContext);\n  if (!ctx) throw new Error('useUserStream must be used within UserStreamProvider');\n  return ctx;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/testUtils/renderWithMantine.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[241,244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[241,244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-var-requires').","line":11,"column":2,"severity":1,"nodeType":null,"fix":{"range":[439,501],"text":" "}},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":12,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":12,"endColumn":46}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import React from 'react';\nimport { render } from '@testing-library/react';\nimport type { RenderOptions } from '@testing-library/react';\n\ninterface MantineRenderOptions extends Omit<RenderOptions, 'queries'> {\n\tmantineProps?: Record<string, any>;\n}\n\n// Uniwersalny helper renderujący z MantineProvider (dynamiczny import zgodny z CJS/ESM)\nexport const renderWithMantine = (ui: React.ReactElement, options: MantineRenderOptions = {}) => {\n\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n\tconst MantineCore = require('@mantine/core');\n\tconst Provider =\n\t\tMantineCore.MantineProvider ||\n\t\tMantineCore.default?.MantineProvider ||\n\t\tMantineCore.default ||\n\t\t(({ children }: { children: React.ReactNode }) => <>{children}</>);\n\n\treturn render(<Provider {...options.mantineProps}>{ui}</Provider>, options);\n};\n\nexport default renderWithMantine;\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/types/asset.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/types/portfolio.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/types/websocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/utils/debugLogger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[341,344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[341,344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[475,478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[475,478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[611,614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[611,614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Debug logger that only logs when in development mode\n * Prevents console.log from blocking main thread in production\n */\nexport class DebugLogger {\n  private prefix: string;\n  private isDev: boolean;\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n    this.isDev = import.meta.env.DEV;\n  }\n\n  log(message: string, ...args: any[]) {\n    if (this.isDev) {\n      console.log(`[${this.prefix}] ${message}`, ...args);\n    }\n  }\n\n  warn(message: string, ...args: any[]) {\n    if (this.isDev) {\n      console.warn(`[${this.prefix}] ${message}`, ...args);\n    }\n  }\n\n  error(message: string, ...args: any[]) {\n    // Always log errors\n    console.error(`[${this.prefix}] ${message}`, ...args);\n  }\n}\n\nexport const createDebugLogger = (prefix: string) => new DebugLogger(prefix);\n","usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/utils/performanceMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/michalstrzalkowski/srinance3-1/frontend/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]